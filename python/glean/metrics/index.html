<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>glean.metrics API documentation</title>
<meta name="description" content="This module contains all of the metric types." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>glean.metrics</code></h1>
</header>
<section id="section-intro">
<p>This module contains all of the metric types.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.


&#34;&#34;&#34;
This module contains all of the metric types.
&#34;&#34;&#34;


from .boolean import BooleanMetricType
from .counter import CounterMetricType
from .datetime import DatetimeMetricType
from .event import EventMetricType, RecordedEventData
from .experiment import RecordedExperimentData
from .quantity import QuantityMetricType
from .jwe import JweMetricType
from .labeled import (
    LabeledBooleanMetricType,
    LabeledCounterMetricType,
    LabeledStringMetricType,
)
from .lifetime import Lifetime
from .memory_distribution import MemoryDistributionMetricType
from .memoryunit import MemoryUnit
from .ping import PingType
from .string import StringMetricType
from .string_list import StringListMetricType
from .timespan import TimespanMetricType
from .timeunit import TimeUnit
from .timing_distribution import TimingDistributionMetricType
from .uuid import UuidMetricType


__all__ = [
    &#34;BooleanMetricType&#34;,
    &#34;CounterMetricType&#34;,
    &#34;DatetimeMetricType&#34;,
    &#34;EventMetricType&#34;,
    &#34;JweMetricType&#34;,
    &#34;QuantityMetricType&#34;,
    &#34;LabeledBooleanMetricType&#34;,
    &#34;LabeledCounterMetricType&#34;,
    &#34;LabeledStringMetricType&#34;,
    &#34;Lifetime&#34;,
    &#34;MemoryDistributionMetricType&#34;,
    &#34;MemoryUnit&#34;,
    &#34;PingType&#34;,
    &#34;RecordedEventData&#34;,
    &#34;RecordedExperimentData&#34;,
    &#34;StringMetricType&#34;,
    &#34;StringListMetricType&#34;,
    &#34;TimespanMetricType&#34;,
    &#34;TimeUnit&#34;,
    &#34;TimingDistributionMetricType&#34;,
    &#34;UuidMetricType&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="glean.metrics.boolean" href="boolean.html">glean.metrics.boolean</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.counter" href="counter.html">glean.metrics.counter</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.datetime" href="datetime.html">glean.metrics.datetime</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.distribution_data" href="distribution_data.html">glean.metrics.distribution_data</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.event" href="event.html">glean.metrics.event</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.experiment" href="experiment.html">glean.metrics.experiment</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.jwe" href="jwe.html">glean.metrics.jwe</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.labeled" href="labeled.html">glean.metrics.labeled</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.lifetime" href="lifetime.html">glean.metrics.lifetime</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.memory_distribution" href="memory_distribution.html">glean.metrics.memory_distribution</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.memoryunit" href="memoryunit.html">glean.metrics.memoryunit</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.ping" href="ping.html">glean.metrics.ping</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.quantity" href="quantity.html">glean.metrics.quantity</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.string" href="string.html">glean.metrics.string</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.string_list" href="string_list.html">glean.metrics.string_list</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.timespan" href="timespan.html">glean.metrics.timespan</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.timeunit" href="timeunit.html">glean.metrics.timeunit</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.timing_distribution" href="timing_distribution.html">glean.metrics.timing_distribution</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="glean.metrics.uuid" href="uuid.html">glean.metrics.uuid</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="glean.metrics.BooleanMetricType"><code class="flex name class">
<span>class <span class="ident">BooleanMetricType</span></span>
<span>(</span><span>disabled: bool, category: str, lifetime: <a title="glean.metrics.lifetime.Lifetime" href="lifetime.html#glean.metrics.lifetime.Lifetime">Lifetime</a>, name: str, send_in_pings: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer facing API for recording boolean metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>The boolean API only exposes the <code><a title="glean.metrics.BooleanMetricType.set" href="#glean.metrics.BooleanMetricType.set">BooleanMetricType.set()</a></code> method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BooleanMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording boolean metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The boolean API only exposes the `BooleanMetricType.set` method
    &#34;&#34;&#34;

    def __init__(
        self,
        disabled: bool,
        category: str,
        lifetime: Lifetime,
        name: str,
        send_in_pings: List[str],
    ):
        self._disabled = disabled
        self._send_in_pings = send_in_pings

        self._handle = _ffi.lib.glean_new_boolean_metric(
            _ffi.ffi_encode_string(category),
            _ffi.ffi_encode_string(name),
            _ffi.ffi_encode_vec_string(send_in_pings),
            len(send_in_pings),
            lifetime.value,
            disabled,
        )

    def __del__(self):
        if getattr(self, &#34;_handle&#34;, 0) != 0:
            _ffi.lib.glean_destroy_boolean_metric(self._handle)

    def set(self, value: bool) -&gt; None:
        &#34;&#34;&#34;
        Set a boolean value.

        Args:
            value (bool): This is a user-defined boolean value.
        &#34;&#34;&#34;
        if self._disabled:
            return

        @Dispatcher.launch
        def set():
            _ffi.lib.glean_boolean_set(self._handle, value)

    def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
        &#34;&#34;&#34;
        Tests whether a value is stored for the metric for testing purposes
        only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            has_value (bool): True if the metric value exists.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return bool(
            _ffi.lib.glean_boolean_test_has_value(
                self._handle, _ffi.ffi_encode_string(ping_name)
            )
        )

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; bool:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (bool): value of the stored metric.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        if not self.test_has_value(ping_name):
            raise ValueError(&#34;metric has no value&#34;)

        return bool(
            _ffi.lib.glean_boolean_test_get_value(
                self._handle, _ffi.ffi_encode_string(ping_name)
            )
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.BooleanMetricType.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, value: bool) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Set a boolean value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>bool</code></dt>
<dd>This is a user-defined boolean value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, value: bool) -&gt; None:
    &#34;&#34;&#34;
    Set a boolean value.

    Args:
        value (bool): This is a user-defined boolean value.
    &#34;&#34;&#34;
    if self._disabled:
        return

    @Dispatcher.launch
    def set():
        _ffi.lib.glean_boolean_set(self._handle, value)</code></pre>
</details>
</dd>
<dt id="glean.metrics.BooleanMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the stored value for testing purposes only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (bool): value of the stored metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; bool:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (bool): value of the stored metric.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    if not self.test_has_value(ping_name):
        raise ValueError(&#34;metric has no value&#34;)

    return bool(
        _ffi.lib.glean_boolean_test_get_value(
            self._handle, _ffi.ffi_encode_string(ping_name)
        )
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.BooleanMetricType.test_has_value"><code class="name flex">
<span>def <span class="ident">test_has_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether a value is stored for the metric for testing purposes
only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>has_value (bool): True if the metric value exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
    &#34;&#34;&#34;
    Tests whether a value is stored for the metric for testing purposes
    only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        has_value (bool): True if the metric value exists.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return bool(
        _ffi.lib.glean_boolean_test_has_value(
            self._handle, _ffi.ffi_encode_string(ping_name)
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.CounterMetricType"><code class="flex name class">
<span>class <span class="ident">CounterMetricType</span></span>
<span>(</span><span>disabled: bool, category: str, lifetime: <a title="glean.metrics.lifetime.Lifetime" href="lifetime.html#glean.metrics.lifetime.Lifetime">Lifetime</a>, name: str, send_in_pings: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer facing API for recording counter metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>The counter API only exposes the <code><a title="glean.metrics.CounterMetricType.add" href="#glean.metrics.CounterMetricType.add">CounterMetricType.add()</a></code> method, which
takes care of validating the input data and making sure that limits are
enforced.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CounterMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording counter metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The counter API only exposes the `CounterMetricType.add` method, which
    takes care of validating the input data and making sure that limits are
    enforced.
    &#34;&#34;&#34;

    def __init__(
        self,
        disabled: bool,
        category: str,
        lifetime: Lifetime,
        name: str,
        send_in_pings: List[str],
    ):
        self._disabled = disabled
        self._send_in_pings = send_in_pings

        self._handle = _ffi.lib.glean_new_counter_metric(
            _ffi.ffi_encode_string(category),
            _ffi.ffi_encode_string(name),
            _ffi.ffi_encode_vec_string(send_in_pings),
            len(send_in_pings),
            lifetime.value,
            disabled,
        )

    def __del__(self):
        if getattr(self, &#34;_handle&#34;, 0) != 0:
            _ffi.lib.glean_destroy_counter_metric(self._handle)

    def add(self, amount: int = 1) -&gt; None:
        &#34;&#34;&#34;
        Add to counter value.

        Args:
            amount (int): (default: 1) This is the amount to increment the
                counter by.
        &#34;&#34;&#34;
        if self._disabled:
            return

        @Dispatcher.launch
        def add():
            _ffi.lib.glean_counter_add(self._handle, amount)

    def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
        &#34;&#34;&#34;
        Tests whether a value is stored for the metric for testing purposes
        only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            has_value (bool): True if the metric value exists.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return bool(
            _ffi.lib.glean_counter_test_has_value(
                self._handle, _ffi.ffi_encode_string(ping_name)
            )
        )

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; int:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (int): value of the stored metric.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        if not self.test_has_value(ping_name):
            raise ValueError(&#34;metric has no value&#34;)

        return _ffi.lib.glean_counter_test_get_value(
            self._handle, _ffi.ffi_encode_string(ping_name)
        )

    def test_get_num_recorded_errors(
        self, error_type: ErrorType, ping_name: Optional[str] = None
    ) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of errors recorded for the given metric.

        Args:
            error_type (ErrorType): The type of error recorded.
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            num_errors (int): The number of errors recorded for the metric for
                the given error type.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return _ffi.lib.glean_counter_test_get_num_recorded_errors(
            self._handle,
            error_type.value,
            _ffi.ffi_encode_string(ping_name),
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.CounterMetricType.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, amount: int = 1) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Add to counter value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>amount</code></strong> :&ensp;<code>int</code></dt>
<dd>(default: 1) This is the amount to increment the
counter by.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, amount: int = 1) -&gt; None:
    &#34;&#34;&#34;
    Add to counter value.

    Args:
        amount (int): (default: 1) This is the amount to increment the
            counter by.
    &#34;&#34;&#34;
    if self._disabled:
        return

    @Dispatcher.launch
    def add():
        _ffi.lib.glean_counter_add(self._handle, amount)</code></pre>
</details>
</dd>
<dt id="glean.metrics.CounterMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: <a title="glean.testing.error_type.ErrorType" href="../testing/error_type.html#glean.testing.error_type.ErrorType">ErrorType</a>, ping_name: Union[str, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of errors recorded for the given metric.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>error_type</code></strong> :&ensp;<code>ErrorType</code></dt>
<dd>The type of error recorded.</dd>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>num_errors (int): The number of errors recorded for the metric for
the given error type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(
    self, error_type: ErrorType, ping_name: Optional[str] = None
) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of errors recorded for the given metric.

    Args:
        error_type (ErrorType): The type of error recorded.
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        num_errors (int): The number of errors recorded for the metric for
            the given error type.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return _ffi.lib.glean_counter_test_get_num_recorded_errors(
        self._handle,
        error_type.value,
        _ffi.ffi_encode_string(ping_name),
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.CounterMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the stored value for testing purposes only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (int): value of the stored metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; int:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (int): value of the stored metric.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    if not self.test_has_value(ping_name):
        raise ValueError(&#34;metric has no value&#34;)

    return _ffi.lib.glean_counter_test_get_value(
        self._handle, _ffi.ffi_encode_string(ping_name)
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.CounterMetricType.test_has_value"><code class="name flex">
<span>def <span class="ident">test_has_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether a value is stored for the metric for testing purposes
only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>has_value (bool): True if the metric value exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
    &#34;&#34;&#34;
    Tests whether a value is stored for the metric for testing purposes
    only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        has_value (bool): True if the metric value exists.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return bool(
        _ffi.lib.glean_counter_test_has_value(
            self._handle, _ffi.ffi_encode_string(ping_name)
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.DatetimeMetricType"><code class="flex name class">
<span>class <span class="ident">DatetimeMetricType</span></span>
<span>(</span><span>disabled: bool, category: str, lifetime: <a title="glean.metrics.lifetime.Lifetime" href="lifetime.html#glean.metrics.lifetime.Lifetime">Lifetime</a>, name: str, send_in_pings: List[str], time_unit: <a title="glean.metrics.timeunit.TimeUnit" href="timeunit.html#glean.metrics.timeunit.TimeUnit">TimeUnit</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer facing API for recording datetime metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>The datetime API only exposes the <code><a title="glean.metrics.DatetimeMetricType.set" href="#glean.metrics.DatetimeMetricType.set">DatetimeMetricType.set()</a></code> method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DatetimeMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording datetime metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The datetime API only exposes the `DatetimeMetricType.set` method.
    &#34;&#34;&#34;

    def __init__(
        self,
        disabled: bool,
        category: str,
        lifetime: Lifetime,
        name: str,
        send_in_pings: List[str],
        time_unit: TimeUnit,
    ):
        self._disabled = disabled
        self._send_in_pings = send_in_pings

        self._handle = _ffi.lib.glean_new_datetime_metric(
            _ffi.ffi_encode_string(category),
            _ffi.ffi_encode_string(name),
            _ffi.ffi_encode_vec_string(send_in_pings),
            len(send_in_pings),
            lifetime.value,
            disabled,
            time_unit.value,
        )

    def __del__(self):
        if getattr(self, &#34;_handle&#34;, 0) != 0:
            _ffi.lib.glean_destroy_datetime_metric(self._handle)

    def set(self, value: Optional[datetime.datetime] = None) -&gt; None:
        &#34;&#34;&#34;
        Set a datetime value, truncating it to the metric&#39;s resolution.

        Args:
            value (datetime.datetime): (default: now) The `datetime.datetime`
                value to set. If not provided, will record the current time.
        &#34;&#34;&#34;
        if self._disabled:
            return

        if value is None:
            value = datetime.datetime.now()

        @Dispatcher.launch
        def set():
            tzinfo = value.tzinfo
            if tzinfo is not None:
                offset = tzinfo.utcoffset(value).seconds
            else:
                offset = 0
            _ffi.lib.glean_datetime_set(
                self._handle,
                value.year,
                value.month,
                value.day,
                value.hour,
                value.minute,
                value.second,
                value.microsecond * 1000,
                offset,
            )

    def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
        &#34;&#34;&#34;
        Tests whether a value is stored for the metric for testing purposes
        only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            has_value (bool): True if the metric value exists.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return bool(
            _ffi.lib.glean_datetime_test_has_value(
                self._handle, _ffi.ffi_encode_string(ping_name)
            )
        )

    def test_get_value_as_str(self, ping_name: Optional[str] = None) -&gt; str:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only, as an ISO8601 string.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (str): value of the stored metric.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        if not self.test_has_value(ping_name):
            raise ValueError(&#34;metric has no value&#34;)

        return _ffi.ffi_decode_string(
            _ffi.lib.glean_datetime_test_get_value_as_string(
                self._handle, _ffi.ffi_encode_string(ping_name)
            )
        )

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; datetime.datetime:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (datetime.datetime): value of the stored metric.
        &#34;&#34;&#34;
        if sys.version_info &lt; (3, 7):
            return iso8601.parse_date(self.test_get_value_as_str(ping_name))
        else:
            return datetime.datetime.fromisoformat(
                self.test_get_value_as_str(ping_name)
            )

    def test_get_num_recorded_errors(
        self, error_type: ErrorType, ping_name: Optional[str] = None
    ) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of errors recorded for the given metric.

        Args:
            error_type (ErrorType): The type of error recorded.
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            num_errors (int): The number of errors recorded for the metric for
                the given error type.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return _ffi.lib.glean_datetime_test_get_num_recorded_errors(
            self._handle,
            error_type.value,
            _ffi.ffi_encode_string(ping_name),
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.DatetimeMetricType.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, value: Union[datetime.datetime, NoneType] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Set a datetime value, truncating it to the metric's resolution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>datetime.datetime</code></dt>
<dd>(default: now) The <code>datetime.datetime</code>
value to set. If not provided, will record the current time.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, value: Optional[datetime.datetime] = None) -&gt; None:
    &#34;&#34;&#34;
    Set a datetime value, truncating it to the metric&#39;s resolution.

    Args:
        value (datetime.datetime): (default: now) The `datetime.datetime`
            value to set. If not provided, will record the current time.
    &#34;&#34;&#34;
    if self._disabled:
        return

    if value is None:
        value = datetime.datetime.now()

    @Dispatcher.launch
    def set():
        tzinfo = value.tzinfo
        if tzinfo is not None:
            offset = tzinfo.utcoffset(value).seconds
        else:
            offset = 0
        _ffi.lib.glean_datetime_set(
            self._handle,
            value.year,
            value.month,
            value.day,
            value.hour,
            value.minute,
            value.second,
            value.microsecond * 1000,
            offset,
        )</code></pre>
</details>
</dd>
<dt id="glean.metrics.DatetimeMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: <a title="glean.testing.error_type.ErrorType" href="../testing/error_type.html#glean.testing.error_type.ErrorType">ErrorType</a>, ping_name: Union[str, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of errors recorded for the given metric.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>error_type</code></strong> :&ensp;<code>ErrorType</code></dt>
<dd>The type of error recorded.</dd>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>num_errors (int): The number of errors recorded for the metric for
the given error type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(
    self, error_type: ErrorType, ping_name: Optional[str] = None
) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of errors recorded for the given metric.

    Args:
        error_type (ErrorType): The type of error recorded.
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        num_errors (int): The number of errors recorded for the metric for
            the given error type.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return _ffi.lib.glean_datetime_test_get_num_recorded_errors(
        self._handle,
        error_type.value,
        _ffi.ffi_encode_string(ping_name),
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.DatetimeMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> datetime.datetime</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the stored value for testing purposes only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (datetime.datetime): value of the stored metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; datetime.datetime:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (datetime.datetime): value of the stored metric.
    &#34;&#34;&#34;
    if sys.version_info &lt; (3, 7):
        return iso8601.parse_date(self.test_get_value_as_str(ping_name))
    else:
        return datetime.datetime.fromisoformat(
            self.test_get_value_as_str(ping_name)
        )</code></pre>
</details>
</dd>
<dt id="glean.metrics.DatetimeMetricType.test_get_value_as_str"><code class="name flex">
<span>def <span class="ident">test_get_value_as_str</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the stored value for testing purposes only, as an ISO8601 string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (str): value of the stored metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value_as_str(self, ping_name: Optional[str] = None) -&gt; str:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only, as an ISO8601 string.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (str): value of the stored metric.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    if not self.test_has_value(ping_name):
        raise ValueError(&#34;metric has no value&#34;)

    return _ffi.ffi_decode_string(
        _ffi.lib.glean_datetime_test_get_value_as_string(
            self._handle, _ffi.ffi_encode_string(ping_name)
        )
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.DatetimeMetricType.test_has_value"><code class="name flex">
<span>def <span class="ident">test_has_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether a value is stored for the metric for testing purposes
only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>has_value (bool): True if the metric value exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
    &#34;&#34;&#34;
    Tests whether a value is stored for the metric for testing purposes
    only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        has_value (bool): True if the metric value exists.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return bool(
        _ffi.lib.glean_datetime_test_has_value(
            self._handle, _ffi.ffi_encode_string(ping_name)
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.EventMetricType"><code class="flex name class">
<span>class <span class="ident">EventMetricType</span></span>
<span>(</span><span>disabled: bool, category: str, lifetime: <a title="glean.metrics.lifetime.Lifetime" href="lifetime.html#glean.metrics.lifetime.Lifetime">Lifetime</a>, name: str, send_in_pings: List[str], allowed_extra_keys: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer facing API for recording events.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>The event API only exposes the <code><a title="glean.metrics.EventMetricType.record" href="#glean.metrics.EventMetricType.record">EventMetricType.record()</a></code> method, which
takes care of validating the input data and making sure that limits are
enforced.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EventMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording events.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The event API only exposes the `EventMetricType.record` method, which
    takes care of validating the input data and making sure that limits are
    enforced.
    &#34;&#34;&#34;

    def __init__(
        self,
        disabled: bool,
        category: str,
        lifetime: Lifetime,
        name: str,
        send_in_pings: List[str],
        allowed_extra_keys: List[str],
    ):
        self._disabled = disabled
        self._send_in_pings = send_in_pings

        self._handle = _ffi.lib.glean_new_event_metric(
            _ffi.ffi_encode_string(category),
            _ffi.ffi_encode_string(name),
            _ffi.ffi_encode_vec_string(send_in_pings),
            len(send_in_pings),
            lifetime.value,
            disabled,
            _ffi.ffi_encode_vec_string(allowed_extra_keys),
            len(allowed_extra_keys),
        )

    def __del__(self):
        if getattr(self, &#34;_handle&#34;, 0) != 0:
            _ffi.lib.glean_destroy_event_metric(self._handle)

    def record(self, extra: Optional[Dict[int, str]] = None) -&gt; None:
        &#34;&#34;&#34;
        Record an event by using the information provided by the instance of
        this class.

        Args:
            extra (dict of (int, str)): optional. This is a map from keys
                (which are enumerations) to values. This is used for events
                where additional richer context is needed. The maximum length
                for values is 100.
        &#34;&#34;&#34;
        if self._disabled:
            return

        timestamp = _ffi.lib.glean_get_timestamp_ms()

        @Dispatcher.launch
        def record():
            if extra is None:
                keys = []
                values = []
                nextra = 0
            else:
                keys, values = zip(*list(extra.items()))
                keys = [x.value for x in keys]
                nextra = len(extra)

            _ffi.lib.glean_event_record(
                self._handle,
                timestamp,
                _ffi.ffi_encode_vec_int32(keys),
                _ffi.ffi_encode_vec_string(values),
                nextra,
            )

    def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
        &#34;&#34;&#34;
        Tests whether a value is stored for the metric for testing purposes
        only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            has_value (bool): True if the metric value exists.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return bool(
            _ffi.lib.glean_event_test_has_value(
                self._handle, _ffi.ffi_encode_string(ping_name)
            )
        )

    def test_get_value(
        self, ping_name: Optional[str] = None
    ) -&gt; List[RecordedEventData]:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (list of RecordedEventData): value of the stored events.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        if not self.test_has_value(ping_name):
            raise ValueError(&#34;metric has no value&#34;)

        json_string = _ffi.ffi_decode_string(
            _ffi.lib.glean_event_test_get_value_as_json_string(
                self._handle, _ffi.ffi_encode_string(ping_name)
            )
        )

        json_content = json.loads(json_string)

        return [RecordedEventData(**x) for x in json_content]

    def test_get_num_recorded_errors(
        self, error_type: ErrorType, ping_name: Optional[str] = None
    ) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of errors recorded for the given metric.

        Args:
            error_type (ErrorType): The type of error recorded.
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            num_errors (int): The number of errors recorded for the metric for
                the given error type.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return _ffi.lib.glean_event_test_get_num_recorded_errors(
            self._handle,
            error_type.value,
            _ffi.ffi_encode_string(ping_name),
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.EventMetricType.record"><code class="name flex">
<span>def <span class="ident">record</span></span>(<span>self, extra: Union[Dict[int, str], NoneType] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Record an event by using the information provided by the instance of
this class.</p>
<h2 id="args">Args</h2>
<p>extra (dict of (int, str)): optional. This is a map from keys
(which are enumerations) to values. This is used for events
where additional richer context is needed. The maximum length
for values is 100.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def record(self, extra: Optional[Dict[int, str]] = None) -&gt; None:
    &#34;&#34;&#34;
    Record an event by using the information provided by the instance of
    this class.

    Args:
        extra (dict of (int, str)): optional. This is a map from keys
            (which are enumerations) to values. This is used for events
            where additional richer context is needed. The maximum length
            for values is 100.
    &#34;&#34;&#34;
    if self._disabled:
        return

    timestamp = _ffi.lib.glean_get_timestamp_ms()

    @Dispatcher.launch
    def record():
        if extra is None:
            keys = []
            values = []
            nextra = 0
        else:
            keys, values = zip(*list(extra.items()))
            keys = [x.value for x in keys]
            nextra = len(extra)

        _ffi.lib.glean_event_record(
            self._handle,
            timestamp,
            _ffi.ffi_encode_vec_int32(keys),
            _ffi.ffi_encode_vec_string(values),
            nextra,
        )</code></pre>
</details>
</dd>
<dt id="glean.metrics.EventMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: <a title="glean.testing.error_type.ErrorType" href="../testing/error_type.html#glean.testing.error_type.ErrorType">ErrorType</a>, ping_name: Union[str, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of errors recorded for the given metric.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>error_type</code></strong> :&ensp;<code>ErrorType</code></dt>
<dd>The type of error recorded.</dd>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>num_errors (int): The number of errors recorded for the metric for
the given error type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(
    self, error_type: ErrorType, ping_name: Optional[str] = None
) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of errors recorded for the given metric.

    Args:
        error_type (ErrorType): The type of error recorded.
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        num_errors (int): The number of errors recorded for the metric for
            the given error type.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return _ffi.lib.glean_event_test_get_num_recorded_errors(
        self._handle,
        error_type.value,
        _ffi.ffi_encode_string(ping_name),
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.EventMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> List[<a title="glean.metrics.event.RecordedEventData" href="event.html#glean.metrics.event.RecordedEventData">RecordedEventData</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the stored value for testing purposes only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (list of RecordedEventData): value of the stored events.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(
    self, ping_name: Optional[str] = None
) -&gt; List[RecordedEventData]:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (list of RecordedEventData): value of the stored events.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    if not self.test_has_value(ping_name):
        raise ValueError(&#34;metric has no value&#34;)

    json_string = _ffi.ffi_decode_string(
        _ffi.lib.glean_event_test_get_value_as_json_string(
            self._handle, _ffi.ffi_encode_string(ping_name)
        )
    )

    json_content = json.loads(json_string)

    return [RecordedEventData(**x) for x in json_content]</code></pre>
</details>
</dd>
<dt id="glean.metrics.EventMetricType.test_has_value"><code class="name flex">
<span>def <span class="ident">test_has_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether a value is stored for the metric for testing purposes
only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>has_value (bool): True if the metric value exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
    &#34;&#34;&#34;
    Tests whether a value is stored for the metric for testing purposes
    only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        has_value (bool): True if the metric value exists.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return bool(
        _ffi.lib.glean_event_test_has_value(
            self._handle, _ffi.ffi_encode_string(ping_name)
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.JweMetricType"><code class="flex name class">
<span>class <span class="ident">JweMetricType</span></span>
<span>(</span><span>disabled: bool, category: str, lifetime: <a title="glean.metrics.lifetime.Lifetime" href="lifetime.html#glean.metrics.lifetime.Lifetime">Lifetime</a>, name: str, send_in_pings: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer facing API for recording JWE metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>The string API exposes the <code><a title="glean.metrics.JweMetricType.set" href="#glean.metrics.JweMetricType.set">JweMetricType.set()</a></code> and
<code>JweMetricType.setWithCompactRepresentation</code> methods,
which take care of validating the input data
and making sure that limits are enforced.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JweMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording JWE metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The string API exposes the `JweMetricType.set` and
    `JweMetricType.setWithCompactRepresentation` methods,
    which take care of validating the input data
    and making sure that limits are enforced.
    &#34;&#34;&#34;

    def __init__(
        self,
        disabled: bool,
        category: str,
        lifetime: Lifetime,
        name: str,
        send_in_pings: List[str],
    ):
        self._disabled = disabled
        self._send_in_pings = send_in_pings

        self._handle = _ffi.lib.glean_new_jwe_metric(
            _ffi.ffi_encode_string(category),
            _ffi.ffi_encode_string(name),
            _ffi.ffi_encode_vec_string(send_in_pings),
            len(send_in_pings),
            lifetime.value,
            disabled,
        )

    def __del__(self):
        if getattr(self, &#34;_handle&#34;, 0) != 0:
            _ffi.lib.glean_destroy_jwe_metric(self._handle)

    def set_with_compact_representation(self, value: str):
        &#34;&#34;&#34;
        Set to the specified JWE value.

        Args:
            value (str): the compact representation of a JWE value.
        &#34;&#34;&#34;
        if self._disabled:
            return

        @Dispatcher.launch
        def set():
            _ffi.lib.glean_jwe_set_with_compact_representation(
                self._handle, _ffi.ffi_encode_string(value)
            )

    def set(
        self, header: str, key: str, init_vector: str, cipher_text: str, auth_tag: str
    ) -&gt; None:
        &#34;&#34;&#34;
        Build a JWE value from its elements and set to it.

        Args:
            header (str): A variable-size JWE protected header.
            key (str): A variable-size encrypted key.
                This can be an empty octet sequence.
            init_vector (str): A fixed-size, 96-bit, base64 encoded Jwe initialization vector.
                If not required by the encryption algorithm, can be an empty octet sequence.
            cipher_text (str): The variable-size base64 encoded cipher text.
            auth_tag (str): A fixed-size, 132-bit, base64 encoded authentication tag.
                Can be an empty octet sequence.
        &#34;&#34;&#34;
        if self._disabled:
            return

        @Dispatcher.launch
        def set():
            _ffi.lib.glean_jwe_set(
                self._handle,
                _ffi.ffi_encode_string(header),
                _ffi.ffi_encode_string(key),
                _ffi.ffi_encode_string(init_vector),
                _ffi.ffi_encode_string(cipher_text),
                _ffi.ffi_encode_string(auth_tag),
            )

    def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
        &#34;&#34;&#34;
        Tests whether a value is stored for the metric for testing purposes
        only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            has_value (bool): True if the metric value exists.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return bool(
            _ffi.lib.glean_jwe_test_has_value(
                self._handle, _ffi.ffi_encode_string(ping_name)
            )
        )

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; JweData:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (JweData): value of the stored metric.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        if not self.test_has_value(ping_name):
            raise ValueError(&#34;metric has no value&#34;)

        json_payload = json.loads(
            _ffi.ffi_decode_string(
                _ffi.lib.glean_jwe_test_get_value_as_json_string(
                    self._handle, _ffi.ffi_encode_string(ping_name)
                )
            )
        )

        return JweData(
            json_payload[&#34;header&#34;],
            json_payload[&#34;key&#34;],
            json_payload[&#34;init_vector&#34;],
            json_payload[&#34;cipher_text&#34;],
            json_payload[&#34;auth_tag&#34;],
        )

    def test_get_compact_representation(self, ping_name: Optional[str] = None) -&gt; str:
        &#34;&#34;&#34;
        Returns the stored value as the compact representation
        for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (JweData): value of the stored metric.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        if not self.test_has_value(ping_name):
            raise ValueError(&#34;metric has no value&#34;)

        return _ffi.ffi_decode_string(
            _ffi.lib.glean_jwe_test_get_value(
                self._handle, _ffi.ffi_encode_string(ping_name)
            )
        )

    def test_get_num_recorded_errors(
        self, error_type: ErrorType, ping_name: Optional[str] = None
    ) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of errors recorded for the given metric.

        Args:
            error_type (ErrorType): The type of error recorded.
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            num_errors (int): The number of errors recorded for the metric for
                the given error type.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return _ffi.lib.glean_jwe_test_get_num_recorded_errors(
            self._handle,
            error_type.value,
            _ffi.ffi_encode_string(ping_name),
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.JweMetricType.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, header: str, key: str, init_vector: str, cipher_text: str, auth_tag: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Build a JWE value from its elements and set to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>header</code></strong> :&ensp;<code>str</code></dt>
<dd>A variable-size JWE protected header.</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>A variable-size encrypted key.
This can be an empty octet sequence.</dd>
<dt><strong><code>init_vector</code></strong> :&ensp;<code>str</code></dt>
<dd>A fixed-size, 96-bit, base64 encoded Jwe initialization vector.
If not required by the encryption algorithm, can be an empty octet sequence.</dd>
<dt><strong><code>cipher_text</code></strong> :&ensp;<code>str</code></dt>
<dd>The variable-size base64 encoded cipher text.</dd>
<dt><strong><code>auth_tag</code></strong> :&ensp;<code>str</code></dt>
<dd>A fixed-size, 132-bit, base64 encoded authentication tag.
Can be an empty octet sequence.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(
    self, header: str, key: str, init_vector: str, cipher_text: str, auth_tag: str
) -&gt; None:
    &#34;&#34;&#34;
    Build a JWE value from its elements and set to it.

    Args:
        header (str): A variable-size JWE protected header.
        key (str): A variable-size encrypted key.
            This can be an empty octet sequence.
        init_vector (str): A fixed-size, 96-bit, base64 encoded Jwe initialization vector.
            If not required by the encryption algorithm, can be an empty octet sequence.
        cipher_text (str): The variable-size base64 encoded cipher text.
        auth_tag (str): A fixed-size, 132-bit, base64 encoded authentication tag.
            Can be an empty octet sequence.
    &#34;&#34;&#34;
    if self._disabled:
        return

    @Dispatcher.launch
    def set():
        _ffi.lib.glean_jwe_set(
            self._handle,
            _ffi.ffi_encode_string(header),
            _ffi.ffi_encode_string(key),
            _ffi.ffi_encode_string(init_vector),
            _ffi.ffi_encode_string(cipher_text),
            _ffi.ffi_encode_string(auth_tag),
        )</code></pre>
</details>
</dd>
<dt id="glean.metrics.JweMetricType.set_with_compact_representation"><code class="name flex">
<span>def <span class="ident">set_with_compact_representation</span></span>(<span>self, value: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Set to the specified JWE value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>the compact representation of a JWE value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_with_compact_representation(self, value: str):
    &#34;&#34;&#34;
    Set to the specified JWE value.

    Args:
        value (str): the compact representation of a JWE value.
    &#34;&#34;&#34;
    if self._disabled:
        return

    @Dispatcher.launch
    def set():
        _ffi.lib.glean_jwe_set_with_compact_representation(
            self._handle, _ffi.ffi_encode_string(value)
        )</code></pre>
</details>
</dd>
<dt id="glean.metrics.JweMetricType.test_get_compact_representation"><code class="name flex">
<span>def <span class="ident">test_get_compact_representation</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the stored value as the compact representation
for testing purposes only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (JweData): value of the stored metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_compact_representation(self, ping_name: Optional[str] = None) -&gt; str:
    &#34;&#34;&#34;
    Returns the stored value as the compact representation
    for testing purposes only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (JweData): value of the stored metric.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    if not self.test_has_value(ping_name):
        raise ValueError(&#34;metric has no value&#34;)

    return _ffi.ffi_decode_string(
        _ffi.lib.glean_jwe_test_get_value(
            self._handle, _ffi.ffi_encode_string(ping_name)
        )
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.JweMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: <a title="glean.testing.error_type.ErrorType" href="../testing/error_type.html#glean.testing.error_type.ErrorType">ErrorType</a>, ping_name: Union[str, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of errors recorded for the given metric.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>error_type</code></strong> :&ensp;<code>ErrorType</code></dt>
<dd>The type of error recorded.</dd>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>num_errors (int): The number of errors recorded for the metric for
the given error type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(
    self, error_type: ErrorType, ping_name: Optional[str] = None
) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of errors recorded for the given metric.

    Args:
        error_type (ErrorType): The type of error recorded.
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        num_errors (int): The number of errors recorded for the metric for
            the given error type.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return _ffi.lib.glean_jwe_test_get_num_recorded_errors(
        self._handle,
        error_type.value,
        _ffi.ffi_encode_string(ping_name),
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.JweMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> glean.metrics.jwe.JweData</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the stored value for testing purposes only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (JweData): value of the stored metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; JweData:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (JweData): value of the stored metric.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    if not self.test_has_value(ping_name):
        raise ValueError(&#34;metric has no value&#34;)

    json_payload = json.loads(
        _ffi.ffi_decode_string(
            _ffi.lib.glean_jwe_test_get_value_as_json_string(
                self._handle, _ffi.ffi_encode_string(ping_name)
            )
        )
    )

    return JweData(
        json_payload[&#34;header&#34;],
        json_payload[&#34;key&#34;],
        json_payload[&#34;init_vector&#34;],
        json_payload[&#34;cipher_text&#34;],
        json_payload[&#34;auth_tag&#34;],
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.JweMetricType.test_has_value"><code class="name flex">
<span>def <span class="ident">test_has_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether a value is stored for the metric for testing purposes
only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>has_value (bool): True if the metric value exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
    &#34;&#34;&#34;
    Tests whether a value is stored for the metric for testing purposes
    only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        has_value (bool): True if the metric value exists.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return bool(
        _ffi.lib.glean_jwe_test_has_value(
            self._handle, _ffi.ffi_encode_string(ping_name)
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.LabeledBooleanMetricType"><code class="flex name class">
<span>class <span class="ident">LabeledBooleanMetricType</span></span>
<span>(</span><span>disabled: bool, category: str, lifetime: <a title="glean.metrics.lifetime.Lifetime" href="lifetime.html#glean.metrics.lifetime.Lifetime">Lifetime</a>, name: str, send_in_pings: List[str], labels: Union[Set[str], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer-facing API for labeled metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>Unlike most metric types, LabeledMetricType does not have its own
corresponding storage, but records metrics for the underlying metric type T
in the storage for that type. The only difference is that labeled metrics
are stored with the special key <code>$category.$name/$label</code>. The collect
method knows how to pull these special values back out of the individual
metric storage and rearrange them correctly in the ping.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LabeledBooleanMetricType(LabeledMetricBase):
    _submetric_type = BooleanMetricType
    _metric_type_instantiator = _ffi.lib.glean_new_labeled_boolean_metric
    _submetric_type_instantiator = _ffi.lib.glean_labeled_boolean_metric_get
    _test_get_num_recorded_errors_ffi = (
        _ffi.lib.glean_labeled_boolean_test_get_num_recorded_errors
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>glean.metrics.labeled.LabeledMetricBase</li>
</ul>
</dd>
<dt id="glean.metrics.LabeledCounterMetricType"><code class="flex name class">
<span>class <span class="ident">LabeledCounterMetricType</span></span>
<span>(</span><span>disabled: bool, category: str, lifetime: <a title="glean.metrics.lifetime.Lifetime" href="lifetime.html#glean.metrics.lifetime.Lifetime">Lifetime</a>, name: str, send_in_pings: List[str], labels: Union[Set[str], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer-facing API for labeled metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>Unlike most metric types, LabeledMetricType does not have its own
corresponding storage, but records metrics for the underlying metric type T
in the storage for that type. The only difference is that labeled metrics
are stored with the special key <code>$category.$name/$label</code>. The collect
method knows how to pull these special values back out of the individual
metric storage and rearrange them correctly in the ping.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LabeledCounterMetricType(LabeledMetricBase):
    _submetric_type = CounterMetricType
    _metric_type_instantiator = _ffi.lib.glean_new_labeled_counter_metric
    _submetric_type_instantiator = _ffi.lib.glean_labeled_counter_metric_get
    _test_get_num_recorded_errors_ffi = (
        _ffi.lib.glean_labeled_counter_test_get_num_recorded_errors
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>glean.metrics.labeled.LabeledMetricBase</li>
</ul>
</dd>
<dt id="glean.metrics.LabeledStringMetricType"><code class="flex name class">
<span>class <span class="ident">LabeledStringMetricType</span></span>
<span>(</span><span>disabled: bool, category: str, lifetime: <a title="glean.metrics.lifetime.Lifetime" href="lifetime.html#glean.metrics.lifetime.Lifetime">Lifetime</a>, name: str, send_in_pings: List[str], labels: Union[Set[str], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer-facing API for labeled metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>Unlike most metric types, LabeledMetricType does not have its own
corresponding storage, but records metrics for the underlying metric type T
in the storage for that type. The only difference is that labeled metrics
are stored with the special key <code>$category.$name/$label</code>. The collect
method knows how to pull these special values back out of the individual
metric storage and rearrange them correctly in the ping.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LabeledStringMetricType(LabeledMetricBase):
    _submetric_type = StringMetricType
    _metric_type_instantiator = _ffi.lib.glean_new_labeled_string_metric
    _submetric_type_instantiator = _ffi.lib.glean_labeled_string_metric_get
    _test_get_num_recorded_errors_ffi = (
        _ffi.lib.glean_labeled_string_test_get_num_recorded_errors
    )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>glean.metrics.labeled.LabeledMetricBase</li>
</ul>
</dd>
<dt id="glean.metrics.Lifetime"><code class="flex name class">
<span>class <span class="ident">Lifetime</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration for the different metric lifetimes that Glean supports.</p>
<p>Metric lifetimes define when a metric is reset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Lifetime(Enum):
    &#34;&#34;&#34;
    An enumeration for the different metric lifetimes that Glean supports.

    Metric lifetimes define when a metric is reset.
    &#34;&#34;&#34;

    PING = _ffi.lib.Lifetime_Ping
    &#34;&#34;&#34;
    The metric is reset with each sent ping
    &#34;&#34;&#34;

    APPLICATION = _ffi.lib.Lifetime_Application
    &#34;&#34;&#34;
    The metric is reset on application restart
    &#34;&#34;&#34;

    USER = _ffi.lib.Lifetime_User
    &#34;&#34;&#34;
    The metric is reset with each user profile
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="glean.metrics.Lifetime.APPLICATION"><code class="name">var <span class="ident">APPLICATION</span></code></dt>
<dd>
<div class="desc"><p>The metric is reset on application restart</p></div>
</dd>
<dt id="glean.metrics.Lifetime.PING"><code class="name">var <span class="ident">PING</span></code></dt>
<dd>
<div class="desc"><p>The metric is reset with each sent ping</p></div>
</dd>
<dt id="glean.metrics.Lifetime.USER"><code class="name">var <span class="ident">USER</span></code></dt>
<dd>
<div class="desc"><p>The metric is reset with each user profile</p></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.MemoryDistributionMetricType"><code class="flex name class">
<span>class <span class="ident">MemoryDistributionMetricType</span></span>
<span>(</span><span>disabled: bool, category: str, lifetime: <a title="glean.metrics.lifetime.Lifetime" href="lifetime.html#glean.metrics.lifetime.Lifetime">Lifetime</a>, name: str, send_in_pings: List[str], memory_unit: <a title="glean.metrics.memoryunit.MemoryUnit" href="memoryunit.html#glean.metrics.memoryunit.MemoryUnit">MemoryUnit</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer facing API for recording memory distribution
metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MemoryDistributionMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording memory distribution
    metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.
    &#34;&#34;&#34;

    def __init__(
        self,
        disabled: bool,
        category: str,
        lifetime: Lifetime,
        name: str,
        send_in_pings: List[str],
        memory_unit: MemoryUnit,
    ):
        self._disabled = disabled
        self._send_in_pings = send_in_pings

        self._handle = _ffi.lib.glean_new_memory_distribution_metric(
            _ffi.ffi_encode_string(category),
            _ffi.ffi_encode_string(name),
            _ffi.ffi_encode_vec_string(send_in_pings),
            len(send_in_pings),
            lifetime.value,
            disabled,
            memory_unit.value,
        )

    def __del__(self):
        if getattr(self, &#34;_handle&#34;, 0) != 0:
            _ffi.lib.glean_destroy_memory_distribution_metric(self._handle)

    def accumulate(self, sample: int) -&gt; None:
        &#34;&#34;&#34;
        Record a single value, in the unit specified by `memory_unit`, to the distribution.

        Args:
            sample: The value to record.
        &#34;&#34;&#34;
        if self._disabled:
            return None

        @Dispatcher.launch
        def accumulate():
            return _ffi.lib.glean_memory_distribution_accumulate(self._handle, sample)

    def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
        &#34;&#34;&#34;
        Tests whether a value is stored for the metric for testing purposes
        only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            has_value (bool): True if the metric value exists.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return bool(
            _ffi.lib.glean_memory_distribution_test_has_value(
                self._handle, _ffi.ffi_encode_string(ping_name)
            )
        )

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; DistributionData:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (DistriubutionData): value of the stored metric.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        if not self.test_has_value(ping_name):
            raise ValueError(&#34;metric has no value&#34;)

        return DistributionData.from_json_string(
            _ffi.ffi_decode_string(
                _ffi.lib.glean_memory_distribution_test_get_value_as_json_string(
                    self._handle, _ffi.ffi_encode_string(ping_name)
                )
            )
        )

    def test_get_num_recorded_errors(
        self, error_type: ErrorType, ping_name: Optional[str] = None
    ) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of errors recorded for the given metric.

        Args:
            error_type (ErrorType): The type of error recorded.
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            num_errors (int): The number of errors recorded for the metric for
                the given error type.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return _ffi.lib.glean_memory_distribution_test_get_num_recorded_errors(
            self._handle,
            error_type.value,
            _ffi.ffi_encode_string(ping_name),
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.MemoryDistributionMetricType.accumulate"><code class="name flex">
<span>def <span class="ident">accumulate</span></span>(<span>self, sample: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Record a single value, in the unit specified by <code>memory_unit</code>, to the distribution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sample</code></strong></dt>
<dd>The value to record.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accumulate(self, sample: int) -&gt; None:
    &#34;&#34;&#34;
    Record a single value, in the unit specified by `memory_unit`, to the distribution.

    Args:
        sample: The value to record.
    &#34;&#34;&#34;
    if self._disabled:
        return None

    @Dispatcher.launch
    def accumulate():
        return _ffi.lib.glean_memory_distribution_accumulate(self._handle, sample)</code></pre>
</details>
</dd>
<dt id="glean.metrics.MemoryDistributionMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: <a title="glean.testing.error_type.ErrorType" href="../testing/error_type.html#glean.testing.error_type.ErrorType">ErrorType</a>, ping_name: Union[str, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of errors recorded for the given metric.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>error_type</code></strong> :&ensp;<code>ErrorType</code></dt>
<dd>The type of error recorded.</dd>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>num_errors (int): The number of errors recorded for the metric for
the given error type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(
    self, error_type: ErrorType, ping_name: Optional[str] = None
) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of errors recorded for the given metric.

    Args:
        error_type (ErrorType): The type of error recorded.
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        num_errors (int): The number of errors recorded for the metric for
            the given error type.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return _ffi.lib.glean_memory_distribution_test_get_num_recorded_errors(
        self._handle,
        error_type.value,
        _ffi.ffi_encode_string(ping_name),
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.MemoryDistributionMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> <a title="glean.metrics.distribution_data.DistributionData" href="distribution_data.html#glean.metrics.distribution_data.DistributionData">DistributionData</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the stored value for testing purposes only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (DistriubutionData): value of the stored metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; DistributionData:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (DistriubutionData): value of the stored metric.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    if not self.test_has_value(ping_name):
        raise ValueError(&#34;metric has no value&#34;)

    return DistributionData.from_json_string(
        _ffi.ffi_decode_string(
            _ffi.lib.glean_memory_distribution_test_get_value_as_json_string(
                self._handle, _ffi.ffi_encode_string(ping_name)
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.MemoryDistributionMetricType.test_has_value"><code class="name flex">
<span>def <span class="ident">test_has_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether a value is stored for the metric for testing purposes
only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>has_value (bool): True if the metric value exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
    &#34;&#34;&#34;
    Tests whether a value is stored for the metric for testing purposes
    only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        has_value (bool): True if the metric value exists.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return bool(
        _ffi.lib.glean_memory_distribution_test_has_value(
            self._handle, _ffi.ffi_encode_string(ping_name)
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.MemoryUnit"><code class="flex name class">
<span>class <span class="ident">MemoryUnit</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration of different resolutions supported by the
<code>glean.metrics.MemoryDistribution</code> metric type.</p>
<p>These use the power-of-2 values of these units, that is, Kilobyte is
pedantically a Kibibyte.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MemoryUnit(IntEnum):
    &#34;&#34;&#34;
    An enumeration of different resolutions supported by the
    `glean.metrics.MemoryDistribution` metric type.

    These use the power-of-2 values of these units, that is, Kilobyte is
    pedantically a Kibibyte.
    &#34;&#34;&#34;

    BYTE = _ffi.lib.MemoryUnit_Byte
    &#34;&#34;&#34;
    Byte: 1 byte.
    &#34;&#34;&#34;

    KILOBYTE = _ffi.lib.MemoryUnit_Kilobyte
    &#34;&#34;&#34;
    Kilobyte: 2^10 bytes
    &#34;&#34;&#34;

    MEGABYTE = _ffi.lib.MemoryUnit_Megabyte
    &#34;&#34;&#34;
    Megabyte: 2^20 bytes
    &#34;&#34;&#34;

    GIGABYTE = _ffi.lib.MemoryUnit_Gigabyte
    &#34;&#34;&#34;
    Gigabyte: 2^30 bytes
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="glean.metrics.MemoryUnit.BYTE"><code class="name">var <span class="ident">BYTE</span></code></dt>
<dd>
<div class="desc"><p>Byte: 1 byte.</p></div>
</dd>
<dt id="glean.metrics.MemoryUnit.GIGABYTE"><code class="name">var <span class="ident">GIGABYTE</span></code></dt>
<dd>
<div class="desc"><p>Gigabyte: 2^30 bytes</p></div>
</dd>
<dt id="glean.metrics.MemoryUnit.KILOBYTE"><code class="name">var <span class="ident">KILOBYTE</span></code></dt>
<dd>
<div class="desc"><p>Kilobyte: 2^10 bytes</p></div>
</dd>
<dt id="glean.metrics.MemoryUnit.MEGABYTE"><code class="name">var <span class="ident">MEGABYTE</span></code></dt>
<dd>
<div class="desc"><p>Megabyte: 2^20 bytes</p></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.PingType"><code class="flex name class">
<span>class <span class="ident">PingType</span></span>
<span>(</span><span>name: str, include_client_id: bool, send_if_empty: bool, reason_codes: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer facing API for custom pings.</p>
<p>The Ping API only exposes the <code><a title="glean.metrics.PingType.submit" href="#glean.metrics.PingType.submit">PingType.submit()</a></code> method, which schedules a
ping for eventual uploading.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PingType:
    def __init__(
        self,
        name: str,
        include_client_id: bool,
        send_if_empty: bool,
        reason_codes: List[str],
    ):
        &#34;&#34;&#34;
        This implements the developer facing API for custom pings.

        The Ping API only exposes the `PingType.submit` method, which schedules a
        ping for eventual uploading.
        &#34;&#34;&#34;
        self._name = name
        self._reason_codes = reason_codes
        self._handle = _ffi.lib.glean_new_ping_type(
            _ffi.ffi_encode_string(name),
            include_client_id,
            send_if_empty,
            _ffi.ffi_encode_vec_string(reason_codes),
            len(reason_codes),
        )
        self._test_callback = None  # type: Optional[Callable[[Optional[str]], None]]
        Glean.register_ping_type(self)

    def __del__(self):
        if self._handle != 0:
            _ffi.lib.glean_destroy_ping_type(self._handle)

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
        Get the name of the ping.
        &#34;&#34;&#34;
        return self._name

    def test_before_next_submit(self, cb: Callable[[Optional[str]], None]):
        &#34;&#34;&#34;
        **Test-only API**

        Attach a callback to be called right before a new ping is submitted.
        The provided function is called exactly once before submitting a ping.

        Note: The callback will be called on any call to submit.
        A ping might not be sent afterwards, e.g. if the ping is otherwise empty (and
        `send_if_empty` is `False`).
        &#34;&#34;&#34;
        assert Dispatcher._testing_mode is True
        self._test_callback = cb

    def submit(self, reason: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Collect and submit the ping for eventual uploading.

        If the ping currently contains no content, it will not be sent.

        Args:
            reason (enum, optional): The reason the ping was submitted.
        &#34;&#34;&#34;
        reason_string: Optional[str] = None
        if reason is not None:
            reason_string = self._reason_codes[reason]
        else:
            reason_string = None

        if self._test_callback is not None:
            self._test_callback(reason_string)
            self._test_callback = None

        Glean._submit_ping(self, reason_string)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="glean.metrics.PingType.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>Get the name of the ping.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;
    Get the name of the ping.
    &#34;&#34;&#34;
    return self._name</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.PingType.submit"><code class="name flex">
<span>def <span class="ident">submit</span></span>(<span>self, reason: Union[int, NoneType] = None) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Collect and submit the ping for eventual uploading.</p>
<p>If the ping currently contains no content, it will not be sent.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reason</code></strong> :&ensp;<code>enum</code>, optional</dt>
<dd>The reason the ping was submitted.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def submit(self, reason: Optional[int] = None) -&gt; None:
    &#34;&#34;&#34;
    Collect and submit the ping for eventual uploading.

    If the ping currently contains no content, it will not be sent.

    Args:
        reason (enum, optional): The reason the ping was submitted.
    &#34;&#34;&#34;
    reason_string: Optional[str] = None
    if reason is not None:
        reason_string = self._reason_codes[reason]
    else:
        reason_string = None

    if self._test_callback is not None:
        self._test_callback(reason_string)
        self._test_callback = None

    Glean._submit_ping(self, reason_string)</code></pre>
</details>
</dd>
<dt id="glean.metrics.PingType.test_before_next_submit"><code class="name flex">
<span>def <span class="ident">test_before_next_submit</span></span>(<span>self, cb: Callable[[Union[str, NoneType]], NoneType])</span>
</code></dt>
<dd>
<div class="desc"><p><strong>Test-only API</strong></p>
<p>Attach a callback to be called right before a new ping is submitted.
The provided function is called exactly once before submitting a ping.</p>
<p>Note: The callback will be called on any call to submit.
A ping might not be sent afterwards, e.g. if the ping is otherwise empty (and
<code>send_if_empty</code> is <code>False</code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_before_next_submit(self, cb: Callable[[Optional[str]], None]):
    &#34;&#34;&#34;
    **Test-only API**

    Attach a callback to be called right before a new ping is submitted.
    The provided function is called exactly once before submitting a ping.

    Note: The callback will be called on any call to submit.
    A ping might not be sent afterwards, e.g. if the ping is otherwise empty (and
    `send_if_empty` is `False`).
    &#34;&#34;&#34;
    assert Dispatcher._testing_mode is True
    self._test_callback = cb</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.QuantityMetricType"><code class="flex name class">
<span>class <span class="ident">QuantityMetricType</span></span>
<span>(</span><span>disabled: bool, category: str, lifetime: <a title="glean.metrics.lifetime.Lifetime" href="lifetime.html#glean.metrics.lifetime.Lifetime">Lifetime</a>, name: str, send_in_pings: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer facing API for recording quantity metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>The quantity API only exposes the <code><a title="glean.metrics.QuantityMetricType.set" href="#glean.metrics.QuantityMetricType.set">QuantityMetricType.set()</a></code> method, which
takes care of validating the input data and making sure that limits are
enforced.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QuantityMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording quantity metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The quantity API only exposes the `QuantityMetricType.set` method, which
    takes care of validating the input data and making sure that limits are
    enforced.
    &#34;&#34;&#34;

    def __init__(
        self,
        disabled: bool,
        category: str,
        lifetime: Lifetime,
        name: str,
        send_in_pings: List[str],
    ):
        self._disabled = disabled
        self._send_in_pings = send_in_pings

        self._handle = _ffi.lib.glean_new_quantity_metric(
            _ffi.ffi_encode_string(category),
            _ffi.ffi_encode_string(name),
            _ffi.ffi_encode_vec_string(send_in_pings),
            len(send_in_pings),
            lifetime.value,
            disabled,
        )

    def __del__(self):
        if getattr(self, &#34;_handle&#34;, 0) != 0:
            _ffi.lib.glean_destroy_quantity_metric(self._handle)

    def set(self, value: int) -&gt; None:
        &#34;&#34;&#34;
        Set a quantity value.

        Args:
            value (int): The value to set. Must be non-negative.
        &#34;&#34;&#34;
        if self._disabled:
            return

        @Dispatcher.launch
        def set():
            _ffi.lib.glean_quantity_set(self._handle, value)

    def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
        &#34;&#34;&#34;
        Tests whether a value is stored for the metric for testing purposes
        only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            has_value (bool): True if the metric value exists.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return bool(
            _ffi.lib.glean_quantity_test_has_value(
                self._handle, _ffi.ffi_encode_string(ping_name)
            )
        )

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; int:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (int): value of the stored metric.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        if not self.test_has_value(ping_name):
            raise ValueError(&#34;metric has no value&#34;)

        return _ffi.lib.glean_quantity_test_get_value(
            self._handle, _ffi.ffi_encode_string(ping_name)
        )

    def test_get_num_recorded_errors(
        self, error_type: ErrorType, ping_name: Optional[str] = None
    ) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of errors recorded for the given metric.

        Args:
            error_type (ErrorType): The type of error recorded.
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            num_errors (int): The number of errors recorded for the metric for
                the given error type.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return _ffi.lib.glean_quantity_test_get_num_recorded_errors(
            self._handle,
            error_type.value,
            _ffi.ffi_encode_string(ping_name),
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.QuantityMetricType.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, value: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Set a quantity value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>int</code></dt>
<dd>The value to set. Must be non-negative.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, value: int) -&gt; None:
    &#34;&#34;&#34;
    Set a quantity value.

    Args:
        value (int): The value to set. Must be non-negative.
    &#34;&#34;&#34;
    if self._disabled:
        return

    @Dispatcher.launch
    def set():
        _ffi.lib.glean_quantity_set(self._handle, value)</code></pre>
</details>
</dd>
<dt id="glean.metrics.QuantityMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: <a title="glean.testing.error_type.ErrorType" href="../testing/error_type.html#glean.testing.error_type.ErrorType">ErrorType</a>, ping_name: Union[str, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of errors recorded for the given metric.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>error_type</code></strong> :&ensp;<code>ErrorType</code></dt>
<dd>The type of error recorded.</dd>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>num_errors (int): The number of errors recorded for the metric for
the given error type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(
    self, error_type: ErrorType, ping_name: Optional[str] = None
) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of errors recorded for the given metric.

    Args:
        error_type (ErrorType): The type of error recorded.
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        num_errors (int): The number of errors recorded for the metric for
            the given error type.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return _ffi.lib.glean_quantity_test_get_num_recorded_errors(
        self._handle,
        error_type.value,
        _ffi.ffi_encode_string(ping_name),
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.QuantityMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the stored value for testing purposes only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (int): value of the stored metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; int:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (int): value of the stored metric.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    if not self.test_has_value(ping_name):
        raise ValueError(&#34;metric has no value&#34;)

    return _ffi.lib.glean_quantity_test_get_value(
        self._handle, _ffi.ffi_encode_string(ping_name)
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.QuantityMetricType.test_has_value"><code class="name flex">
<span>def <span class="ident">test_has_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether a value is stored for the metric for testing purposes
only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>has_value (bool): True if the metric value exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
    &#34;&#34;&#34;
    Tests whether a value is stored for the metric for testing purposes
    only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        has_value (bool): True if the metric value exists.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return bool(
        _ffi.lib.glean_quantity_test_has_value(
            self._handle, _ffi.ffi_encode_string(ping_name)
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.RecordedEventData"><code class="flex name class">
<span>class <span class="ident">RecordedEventData</span></span>
<span>(</span><span>category: str, name: str, timestamp: int, extra: Union[Dict[str, str], NoneType] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Deserialized event data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>category</code></strong> :&ensp;<code>str</code></dt>
<dd>The event's category, part of the full identifier.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The event's name, part of the full identifier.</dd>
<dt><strong><code>timestamp</code></strong> :&ensp;<code>int</code></dt>
<dd>The event's timestamp, in milliseconds.</dd>
</dl>
<p>extra (dict of str-&gt;str): Optional. Any extra data recorded for
the event.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RecordedEventData:
    &#34;&#34;&#34;
    Deserialized event data.
    &#34;&#34;&#34;

    def __init__(
        self,
        category: str,
        name: str,
        timestamp: int,
        extra: Optional[Dict[str, str]] = None,
    ):
        &#34;&#34;&#34;
        Args:
            category (str): The event&#39;s category, part of the full identifier.
            name (str): The event&#39;s name, part of the full identifier.
            timestamp (int): The event&#39;s timestamp, in milliseconds.
            extra (dict of str-&gt;str): Optional. Any extra data recorded for
                the event.
        &#34;&#34;&#34;
        self._category = category
        self._name = name
        self._timestamp = timestamp
        if extra is None:
            extra = {}
        self._extra = extra

    @property
    def category(self) -&gt; str:
        &#34;&#34;&#34;The event&#39;s category, part of the full identifier.&#34;&#34;&#34;
        return self._category

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;The event&#39;s name, part of the full identifier.&#34;&#34;&#34;
        return self._name

    @property
    def timestamp(self) -&gt; int:
        &#34;&#34;&#34;The event&#39;s timestamp.&#34;&#34;&#34;
        return self._timestamp

    @property
    def extra(self) -&gt; Optional[Dict[str, str]]:
        &#34;&#34;&#34;Any extra data recorded for the event.&#34;&#34;&#34;
        return self._extra

    @property
    def identifier(self) -&gt; str:
        if self.category == &#34;&#34;:
            return self.name
        else:
            return &#34;.&#34;.join([self.category, self.name])</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="glean.metrics.RecordedEventData.category"><code class="name">var <span class="ident">category</span> : str</code></dt>
<dd>
<div class="desc"><p>The event's category, part of the full identifier.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def category(self) -&gt; str:
    &#34;&#34;&#34;The event&#39;s category, part of the full identifier.&#34;&#34;&#34;
    return self._category</code></pre>
</details>
</dd>
<dt id="glean.metrics.RecordedEventData.extra"><code class="name">var <span class="ident">extra</span> : Union[Dict[str, str], NoneType]</code></dt>
<dd>
<div class="desc"><p>Any extra data recorded for the event.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def extra(self) -&gt; Optional[Dict[str, str]]:
    &#34;&#34;&#34;Any extra data recorded for the event.&#34;&#34;&#34;
    return self._extra</code></pre>
</details>
</dd>
<dt id="glean.metrics.RecordedEventData.identifier"><code class="name">var <span class="ident">identifier</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def identifier(self) -&gt; str:
    if self.category == &#34;&#34;:
        return self.name
    else:
        return &#34;.&#34;.join([self.category, self.name])</code></pre>
</details>
</dd>
<dt id="glean.metrics.RecordedEventData.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>The event's name, part of the full identifier.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;The event&#39;s name, part of the full identifier.&#34;&#34;&#34;
    return self._name</code></pre>
</details>
</dd>
<dt id="glean.metrics.RecordedEventData.timestamp"><code class="name">var <span class="ident">timestamp</span> : int</code></dt>
<dd>
<div class="desc"><p>The event's timestamp.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def timestamp(self) -&gt; int:
    &#34;&#34;&#34;The event&#39;s timestamp.&#34;&#34;&#34;
    return self._timestamp</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.RecordedExperimentData"><code class="flex name class">
<span>class <span class="ident">RecordedExperimentData</span></span>
<span>(</span><span>branch: str, extra: Dict[str, str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Deserialized experiment data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>branch</code></strong> :&ensp;<code>str</code></dt>
<dd>The experiment's branch.</dd>
</dl>
<p>extra (dict of str-&gt;str): Any extra data associated with this
experiment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RecordedExperimentData:
    &#34;&#34;&#34;
    Deserialized experiment data.
    &#34;&#34;&#34;

    def __init__(self, branch: str, extra: Dict[str, str] = None):
        &#34;&#34;&#34;
        Args:
            branch (str): The experiment&#39;s branch.
            extra (dict of str-&gt;str): Any extra data associated with this
                experiment.
        &#34;&#34;&#34;
        self._branch = branch
        if extra is None:
            extra = {}
        self._extra = extra

    @property
    def branch(self) -&gt; str:
        &#34;&#34;&#34;The experiment&#39;s branch.&#34;&#34;&#34;
        return self._branch

    @property
    def extra(self) -&gt; Dict[str, str]:
        &#34;&#34;&#34;Any extra data associated with this experiment.&#34;&#34;&#34;
        return self._extra</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="glean.metrics.RecordedExperimentData.branch"><code class="name">var <span class="ident">branch</span> : str</code></dt>
<dd>
<div class="desc"><p>The experiment's branch.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def branch(self) -&gt; str:
    &#34;&#34;&#34;The experiment&#39;s branch.&#34;&#34;&#34;
    return self._branch</code></pre>
</details>
</dd>
<dt id="glean.metrics.RecordedExperimentData.extra"><code class="name">var <span class="ident">extra</span> : Dict[str, str]</code></dt>
<dd>
<div class="desc"><p>Any extra data associated with this experiment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def extra(self) -&gt; Dict[str, str]:
    &#34;&#34;&#34;Any extra data associated with this experiment.&#34;&#34;&#34;
    return self._extra</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.StringListMetricType"><code class="flex name class">
<span>class <span class="ident">StringListMetricType</span></span>
<span>(</span><span>disabled: bool, category: str, lifetime: <a title="glean.metrics.lifetime.Lifetime" href="lifetime.html#glean.metrics.lifetime.Lifetime">Lifetime</a>, name: str, send_in_pings: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer facing API for recording string list metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>The stringlist API only exposes the <code><a title="glean.metrics.StringListMetricType.set" href="#glean.metrics.StringListMetricType.set">StringListMetricType.set()</a></code> and
<code><a title="glean.metrics.StringListMetricType.add" href="#glean.metrics.StringListMetricType.add">StringListMetricType.add()</a></code> methods, which takes case of validating the
input data and making sure that limits are enforced.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StringListMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording string list metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The stringlist API only exposes the `StringListMetricType.set` and
    `StringListMetricType.add` methods, which takes case of validating the
    input data and making sure that limits are enforced.
    &#34;&#34;&#34;

    def __init__(
        self,
        disabled: bool,
        category: str,
        lifetime: Lifetime,
        name: str,
        send_in_pings: List[str],
    ):
        self._disabled = disabled
        self._send_in_pings = send_in_pings

        self._handle = _ffi.lib.glean_new_string_list_metric(
            _ffi.ffi_encode_string(category),
            _ffi.ffi_encode_string(name),
            _ffi.ffi_encode_vec_string(send_in_pings),
            len(send_in_pings),
            lifetime.value,
            disabled,
        )

    def __del__(self):
        if getattr(self, &#34;_handle&#34;, 0) != 0:
            _ffi.lib.glean_destroy_string_list_metric(self._handle)

    def add(self, value: str) -&gt; None:
        &#34;&#34;&#34;
        Appends a string value to one or more string list metric stores. If the
        string exceeds the maximum string length or if the list exceeds the
        maximum length it will be truncated.

        Args:
            value (str): The is the user defined string value.
        &#34;&#34;&#34;
        if self._disabled:
            return

        @Dispatcher.launch
        def set():
            _ffi.lib.glean_string_list_add(self._handle, _ffi.ffi_encode_string(value))

    def set(self, value: Iterable[str]) -&gt; None:
        &#34;&#34;&#34;
        Sets a string list to one or more metric stores. If any string exceeds
        the maximum string length or if the list exceeds the maximum length it
        will be truncated.

        Args:
            value (iterator over str): This is a user-defined string list.
        &#34;&#34;&#34;
        if self._disabled:
            return

        @Dispatcher.launch
        def set():
            values = list(value)
            _ffi.lib.glean_string_list_set(
                self._handle, _ffi.ffi_encode_vec_string(values), len(values)
            )

    def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
        &#34;&#34;&#34;
        Tests whether a value is stored for the metric for testing purposes
        only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            has_value (bool): True if the metric value exists.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return bool(
            _ffi.lib.glean_string_list_test_has_value(
                self._handle, _ffi.ffi_encode_string(ping_name)
            )
        )

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; List[str]:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (bool): value of the stored metric.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        if not self.test_has_value(ping_name):
            raise ValueError(&#34;metric has no value&#34;)

        return json.loads(
            _ffi.ffi_decode_string(
                _ffi.lib.glean_string_list_test_get_value_as_json_string(
                    self._handle, _ffi.ffi_encode_string(ping_name)
                )
            )
        )

    def test_get_num_recorded_errors(
        self, error_type: ErrorType, ping_name: Optional[str] = None
    ) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of errors recorded for the given metric.

        Args:
            error_type (ErrorType): The type of error recorded.
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            num_errors (int): The number of errors recorded for the metric for
                the given error type.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return _ffi.lib.glean_string_list_test_get_num_recorded_errors(
            self._handle,
            error_type.value,
            _ffi.ffi_encode_string(ping_name),
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.StringListMetricType.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, value: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Appends a string value to one or more string list metric stores. If the
string exceeds the maximum string length or if the list exceeds the
maximum length it will be truncated.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>The is the user defined string value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, value: str) -&gt; None:
    &#34;&#34;&#34;
    Appends a string value to one or more string list metric stores. If the
    string exceeds the maximum string length or if the list exceeds the
    maximum length it will be truncated.

    Args:
        value (str): The is the user defined string value.
    &#34;&#34;&#34;
    if self._disabled:
        return

    @Dispatcher.launch
    def set():
        _ffi.lib.glean_string_list_add(self._handle, _ffi.ffi_encode_string(value))</code></pre>
</details>
</dd>
<dt id="glean.metrics.StringListMetricType.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, value: Iterable[str]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Sets a string list to one or more metric stores. If any string exceeds
the maximum string length or if the list exceeds the maximum length it
will be truncated.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>iterator over str</code></dt>
<dd>This is a user-defined string list.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, value: Iterable[str]) -&gt; None:
    &#34;&#34;&#34;
    Sets a string list to one or more metric stores. If any string exceeds
    the maximum string length or if the list exceeds the maximum length it
    will be truncated.

    Args:
        value (iterator over str): This is a user-defined string list.
    &#34;&#34;&#34;
    if self._disabled:
        return

    @Dispatcher.launch
    def set():
        values = list(value)
        _ffi.lib.glean_string_list_set(
            self._handle, _ffi.ffi_encode_vec_string(values), len(values)
        )</code></pre>
</details>
</dd>
<dt id="glean.metrics.StringListMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: <a title="glean.testing.error_type.ErrorType" href="../testing/error_type.html#glean.testing.error_type.ErrorType">ErrorType</a>, ping_name: Union[str, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of errors recorded for the given metric.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>error_type</code></strong> :&ensp;<code>ErrorType</code></dt>
<dd>The type of error recorded.</dd>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>num_errors (int): The number of errors recorded for the metric for
the given error type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(
    self, error_type: ErrorType, ping_name: Optional[str] = None
) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of errors recorded for the given metric.

    Args:
        error_type (ErrorType): The type of error recorded.
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        num_errors (int): The number of errors recorded for the metric for
            the given error type.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return _ffi.lib.glean_string_list_test_get_num_recorded_errors(
        self._handle,
        error_type.value,
        _ffi.ffi_encode_string(ping_name),
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.StringListMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the stored value for testing purposes only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (bool): value of the stored metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; List[str]:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (bool): value of the stored metric.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    if not self.test_has_value(ping_name):
        raise ValueError(&#34;metric has no value&#34;)

    return json.loads(
        _ffi.ffi_decode_string(
            _ffi.lib.glean_string_list_test_get_value_as_json_string(
                self._handle, _ffi.ffi_encode_string(ping_name)
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.StringListMetricType.test_has_value"><code class="name flex">
<span>def <span class="ident">test_has_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether a value is stored for the metric for testing purposes
only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>has_value (bool): True if the metric value exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
    &#34;&#34;&#34;
    Tests whether a value is stored for the metric for testing purposes
    only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        has_value (bool): True if the metric value exists.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return bool(
        _ffi.lib.glean_string_list_test_has_value(
            self._handle, _ffi.ffi_encode_string(ping_name)
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.StringMetricType"><code class="flex name class">
<span>class <span class="ident">StringMetricType</span></span>
<span>(</span><span>disabled: bool, category: str, lifetime: <a title="glean.metrics.lifetime.Lifetime" href="lifetime.html#glean.metrics.lifetime.Lifetime">Lifetime</a>, name: str, send_in_pings: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer facing API for recording string metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>The string API only exposes the <code><a title="glean.metrics.StringMetricType.set" href="#glean.metrics.StringMetricType.set">StringMetricType.set()</a></code> method, which
takes care of validating the input data and making sure that limits are
enforced.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StringMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording string metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The string API only exposes the `StringMetricType.set` method, which
    takes care of validating the input data and making sure that limits are
    enforced.
    &#34;&#34;&#34;

    def __init__(
        self,
        disabled: bool,
        category: str,
        lifetime: Lifetime,
        name: str,
        send_in_pings: List[str],
    ):
        self._disabled = disabled
        self._send_in_pings = send_in_pings

        self._handle = _ffi.lib.glean_new_string_metric(
            _ffi.ffi_encode_string(category),
            _ffi.ffi_encode_string(name),
            _ffi.ffi_encode_vec_string(send_in_pings),
            len(send_in_pings),
            lifetime.value,
            disabled,
        )

    def __del__(self):
        if getattr(self, &#34;_handle&#34;, 0) != 0:
            _ffi.lib.glean_destroy_string_metric(self._handle)

    def set(self, value: str) -&gt; None:
        &#34;&#34;&#34;
        Set a string value.

        Args:
            value (str): This is a user-defined string value. If the length of
                the string exceeds the maximum length, it will be truncated.
        &#34;&#34;&#34;
        if self._disabled:
            return

        @Dispatcher.launch
        def set():
            _ffi.lib.glean_string_set(self._handle, _ffi.ffi_encode_string(value))

    def _set_sync(self, value: str) -&gt; None:
        &#34;&#34;&#34;
        Set a string value, synchronously.

        Args:
            value (str): This is a user-defined string value. If the length of
                the string exceeds the maximum length, it will be truncated.
        &#34;&#34;&#34;
        if self._disabled:
            return

        _ffi.lib.glean_string_set(self._handle, _ffi.ffi_encode_string(value))

    def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
        &#34;&#34;&#34;
        Tests whether a value is stored for the metric for testing purposes
        only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            has_value (bool): True if the metric value exists.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return bool(
            _ffi.lib.glean_string_test_has_value(
                self._handle, _ffi.ffi_encode_string(ping_name)
            )
        )

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; str:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (int): value of the stored metric.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        if not self.test_has_value(ping_name):
            raise ValueError(&#34;metric has no value&#34;)

        return _ffi.ffi_decode_string(
            _ffi.lib.glean_string_test_get_value(
                self._handle, _ffi.ffi_encode_string(ping_name)
            )
        )

    def test_get_num_recorded_errors(
        self, error_type: ErrorType, ping_name: Optional[str] = None
    ) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of errors recorded for the given metric.

        Args:
            error_type (ErrorType): The type of error recorded.
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            num_errors (int): The number of errors recorded for the metric for
                the given error type.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return _ffi.lib.glean_string_test_get_num_recorded_errors(
            self._handle,
            error_type.value,
            _ffi.ffi_encode_string(ping_name),
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.StringMetricType.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, value: str) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Set a string value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>This is a user-defined string value. If the length of
the string exceeds the maximum length, it will be truncated.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, value: str) -&gt; None:
    &#34;&#34;&#34;
    Set a string value.

    Args:
        value (str): This is a user-defined string value. If the length of
            the string exceeds the maximum length, it will be truncated.
    &#34;&#34;&#34;
    if self._disabled:
        return

    @Dispatcher.launch
    def set():
        _ffi.lib.glean_string_set(self._handle, _ffi.ffi_encode_string(value))</code></pre>
</details>
</dd>
<dt id="glean.metrics.StringMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: <a title="glean.testing.error_type.ErrorType" href="../testing/error_type.html#glean.testing.error_type.ErrorType">ErrorType</a>, ping_name: Union[str, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of errors recorded for the given metric.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>error_type</code></strong> :&ensp;<code>ErrorType</code></dt>
<dd>The type of error recorded.</dd>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>num_errors (int): The number of errors recorded for the metric for
the given error type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(
    self, error_type: ErrorType, ping_name: Optional[str] = None
) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of errors recorded for the given metric.

    Args:
        error_type (ErrorType): The type of error recorded.
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        num_errors (int): The number of errors recorded for the metric for
            the given error type.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return _ffi.lib.glean_string_test_get_num_recorded_errors(
        self._handle,
        error_type.value,
        _ffi.ffi_encode_string(ping_name),
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.StringMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the stored value for testing purposes only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (int): value of the stored metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; str:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (int): value of the stored metric.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    if not self.test_has_value(ping_name):
        raise ValueError(&#34;metric has no value&#34;)

    return _ffi.ffi_decode_string(
        _ffi.lib.glean_string_test_get_value(
            self._handle, _ffi.ffi_encode_string(ping_name)
        )
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.StringMetricType.test_has_value"><code class="name flex">
<span>def <span class="ident">test_has_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether a value is stored for the metric for testing purposes
only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>has_value (bool): True if the metric value exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
    &#34;&#34;&#34;
    Tests whether a value is stored for the metric for testing purposes
    only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        has_value (bool): True if the metric value exists.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return bool(
        _ffi.lib.glean_string_test_has_value(
            self._handle, _ffi.ffi_encode_string(ping_name)
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.TimeUnit"><code class="flex name class">
<span>class <span class="ident">TimeUnit</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enumeration of different resolutions supported by the time-related
metric types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeUnit(IntEnum):
    &#34;&#34;&#34;
    An enumeration of different resolutions supported by the time-related
    metric types.
    &#34;&#34;&#34;

    NANOSECOND = _ffi.lib.TimeUnit_Nanosecond
    &#34;&#34;&#34;
    Represents nanosecond precision.
    &#34;&#34;&#34;

    MICROSECOND = _ffi.lib.TimeUnit_Microsecond
    &#34;&#34;&#34;
    Represents microsecond precision.
    &#34;&#34;&#34;

    MILLISECOND = _ffi.lib.TimeUnit_Millisecond
    &#34;&#34;&#34;
    Represents millisecond precision.
    &#34;&#34;&#34;

    SECOND = _ffi.lib.TimeUnit_Second
    &#34;&#34;&#34;
    Represents second precision.
    &#34;&#34;&#34;

    MINUTE = _ffi.lib.TimeUnit_Minute
    &#34;&#34;&#34;
    Represents minute precision.
    &#34;&#34;&#34;

    HOUR = _ffi.lib.TimeUnit_Hour
    &#34;&#34;&#34;
    Represents hour precision.
    &#34;&#34;&#34;

    DAY = _ffi.lib.TimeUnit_Day
    &#34;&#34;&#34;
    Represents day precision.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.IntEnum</li>
<li>builtins.int</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="glean.metrics.TimeUnit.DAY"><code class="name">var <span class="ident">DAY</span></code></dt>
<dd>
<div class="desc"><p>Represents day precision.</p></div>
</dd>
<dt id="glean.metrics.TimeUnit.HOUR"><code class="name">var <span class="ident">HOUR</span></code></dt>
<dd>
<div class="desc"><p>Represents hour precision.</p></div>
</dd>
<dt id="glean.metrics.TimeUnit.MICROSECOND"><code class="name">var <span class="ident">MICROSECOND</span></code></dt>
<dd>
<div class="desc"><p>Represents microsecond precision.</p></div>
</dd>
<dt id="glean.metrics.TimeUnit.MILLISECOND"><code class="name">var <span class="ident">MILLISECOND</span></code></dt>
<dd>
<div class="desc"><p>Represents millisecond precision.</p></div>
</dd>
<dt id="glean.metrics.TimeUnit.MINUTE"><code class="name">var <span class="ident">MINUTE</span></code></dt>
<dd>
<div class="desc"><p>Represents minute precision.</p></div>
</dd>
<dt id="glean.metrics.TimeUnit.NANOSECOND"><code class="name">var <span class="ident">NANOSECOND</span></code></dt>
<dd>
<div class="desc"><p>Represents nanosecond precision.</p></div>
</dd>
<dt id="glean.metrics.TimeUnit.SECOND"><code class="name">var <span class="ident">SECOND</span></code></dt>
<dd>
<div class="desc"><p>Represents second precision.</p></div>
</dd>
</dl>
</dd>
<dt id="glean.metrics.TimespanMetricType"><code class="flex name class">
<span>class <span class="ident">TimespanMetricType</span></span>
<span>(</span><span>disabled: bool, category: str, lifetime: <a title="glean.metrics.lifetime.Lifetime" href="lifetime.html#glean.metrics.lifetime.Lifetime">Lifetime</a>, name: str, send_in_pings: List[str], time_unit: <a title="glean.metrics.timeunit.TimeUnit" href="timeunit.html#glean.metrics.timeunit.TimeUnit">TimeUnit</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer facing API for recording timespan metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>The timespan API exposes the <code><a title="glean.metrics.TimespanMetricType.start" href="#glean.metrics.TimespanMetricType.start">TimespanMetricType.start()</a></code>,
<code><a title="glean.metrics.TimespanMetricType.stop" href="#glean.metrics.TimespanMetricType.stop">TimespanMetricType.stop()</a></code> and <code><a title="glean.metrics.TimespanMetricType.cancel" href="#glean.metrics.TimespanMetricType.cancel">TimespanMetricType.cancel()</a></code> methods.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimespanMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording timespan metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The timespan API exposes the `TimespanMetricType.start`,
    `TimespanMetricType.stop` and `TimespanMetricType.cancel` methods.
    &#34;&#34;&#34;

    def __init__(
        self,
        disabled: bool,
        category: str,
        lifetime: Lifetime,
        name: str,
        send_in_pings: List[str],
        time_unit: TimeUnit,
    ):
        self._disabled = disabled
        self._send_in_pings = send_in_pings

        self._handle = _ffi.lib.glean_new_timespan_metric(
            _ffi.ffi_encode_string(category),
            _ffi.ffi_encode_string(name),
            _ffi.ffi_encode_vec_string(send_in_pings),
            len(send_in_pings),
            lifetime.value,
            disabled,
            time_unit.value,
        )

    def __del__(self):
        if getattr(self, &#34;_handle&#34;, 0) != 0:
            _ffi.lib.glean_destroy_timespan_metric(self._handle)

    def start(self) -&gt; None:
        &#34;&#34;&#34;
        Start tracking time for the provided metric.

        This records an error if it’s already tracking time (i.e. `start` was
        already called with no corresponding `stop`): in that case the original
        start time will be preserved.
        &#34;&#34;&#34;
        if self._disabled:
            return

        start_time = _util.time_ns()

        @Dispatcher.launch
        def start():
            _ffi.lib.glean_timespan_set_start(self._handle, start_time)

    def stop(self) -&gt; None:
        &#34;&#34;&#34;
        Stop tracking time for the provided metric.

        Sets the metric to the elapsed time, but does not overwrite an already
        existing value.
        This will record an error if no `start` was called or there is an already
        existing value.
        &#34;&#34;&#34;
        if self._disabled:
            return

        stop_time = _util.time_ns()

        @Dispatcher.launch
        def stop():
            _ffi.lib.glean_timespan_set_stop(self._handle, stop_time)

    def cancel(self) -&gt; None:
        &#34;&#34;&#34;
        Abort a previous `start` call. No error is recorded if no `start` was called.
        &#34;&#34;&#34;
        if self._disabled:
            return

        @Dispatcher.launch
        def cancel():
            _ffi.lib.glean_timespan_cancel(self._handle)

    class _TimespanContextManager:
        &#34;&#34;&#34;
        A context manager for recording timings. Used by the `measure` method.
        &#34;&#34;&#34;

        def __init__(self, timespan: &#34;TimespanMetricType&#34;):
            self._timespan = timespan

        def __enter__(self) -&gt; None:
            self._timespan.start()

        def __exit__(self, type, value, tb) -&gt; None:
            if tb is None:
                self._timespan.stop()
            else:
                self._timespan.cancel()

    def measure(self) -&gt; &#34;_TimespanContextManager&#34;:
        &#34;&#34;&#34;
        Provides a context manager for measuring the time it takes to execute
        snippets of code in a `with` statement.

        If the contents of the `with` statement raise an exception, the timing
        is not recorded.

        Usage:
            with metrics.perf.timer.measure():
                # ... do something that takes time ...
        &#34;&#34;&#34;
        return self._TimespanContextManager(self)

    def set_raw_nanos(self, elapsed_nanos: int) -&gt; None:
        &#34;&#34;&#34;
        Explicitly set the timespan value, in nanoseconds.

        This API should only be used if your library or application requires recording
        times in a way that can not make use of [start]/[stop]/[cancel].

        [setRawNanos] does not overwrite a running timer or an already existing value.

        Args:
            elapsed_nanos (int): The elapsed time to record, in nanoseconds.
        &#34;&#34;&#34;
        if self._disabled:
            return

        @Dispatcher.launch
        def set_raw_nanos():
            _ffi.lib.glean_timespan_set_raw_nanos(self._handle, elapsed_nanos)

    def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
        &#34;&#34;&#34;
        Tests whether a value is stored for the metric for testing purposes
        only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            has_value (bool): True if the metric value exists.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return bool(
            _ffi.lib.glean_timespan_test_has_value(
                self._handle, _ffi.ffi_encode_string(ping_name)
            )
        )

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; int:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (bool): value of the stored metric.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        if not self.test_has_value(ping_name):
            raise ValueError(&#34;metric has no value&#34;)

        return _ffi.lib.glean_timespan_test_get_value(
            self._handle, _ffi.ffi_encode_string(ping_name)
        )

    def test_get_num_recorded_errors(
        self, error_type: ErrorType, ping_name: Optional[str] = None
    ) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of errors recorded for the given metric.

        Args:
            error_type (ErrorType): The type of error recorded.
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            num_errors (int): The number of errors recorded for the metric for
                the given error type.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return _ffi.lib.glean_timespan_test_get_num_recorded_errors(
            self._handle,
            error_type.value,
            _ffi.ffi_encode_string(ping_name),
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.TimespanMetricType.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Abort a previous <code>start</code> call. No error is recorded if no <code>start</code> was called.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel(self) -&gt; None:
    &#34;&#34;&#34;
    Abort a previous `start` call. No error is recorded if no `start` was called.
    &#34;&#34;&#34;
    if self._disabled:
        return

    @Dispatcher.launch
    def cancel():
        _ffi.lib.glean_timespan_cancel(self._handle)</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimespanMetricType.measure"><code class="name flex">
<span>def <span class="ident">measure</span></span>(<span>self) ‑> _TimespanContextManager</span>
</code></dt>
<dd>
<div class="desc"><p>Provides a context manager for measuring the time it takes to execute
snippets of code in a <code>with</code> statement.</p>
<p>If the contents of the <code>with</code> statement raise an exception, the timing
is not recorded.</p>
<h2 id="usage">Usage</h2>
<p>with metrics.perf.timer.measure():
# &hellip; do something that takes time &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def measure(self) -&gt; &#34;_TimespanContextManager&#34;:
    &#34;&#34;&#34;
    Provides a context manager for measuring the time it takes to execute
    snippets of code in a `with` statement.

    If the contents of the `with` statement raise an exception, the timing
    is not recorded.

    Usage:
        with metrics.perf.timer.measure():
            # ... do something that takes time ...
    &#34;&#34;&#34;
    return self._TimespanContextManager(self)</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimespanMetricType.set_raw_nanos"><code class="name flex">
<span>def <span class="ident">set_raw_nanos</span></span>(<span>self, elapsed_nanos: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Explicitly set the timespan value, in nanoseconds.</p>
<p>This API should only be used if your library or application requires recording
times in a way that can not make use of [start]/[stop]/[cancel].</p>
<p>[setRawNanos] does not overwrite a running timer or an already existing value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>elapsed_nanos</code></strong> :&ensp;<code>int</code></dt>
<dd>The elapsed time to record, in nanoseconds.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_raw_nanos(self, elapsed_nanos: int) -&gt; None:
    &#34;&#34;&#34;
    Explicitly set the timespan value, in nanoseconds.

    This API should only be used if your library or application requires recording
    times in a way that can not make use of [start]/[stop]/[cancel].

    [setRawNanos] does not overwrite a running timer or an already existing value.

    Args:
        elapsed_nanos (int): The elapsed time to record, in nanoseconds.
    &#34;&#34;&#34;
    if self._disabled:
        return

    @Dispatcher.launch
    def set_raw_nanos():
        _ffi.lib.glean_timespan_set_raw_nanos(self._handle, elapsed_nanos)</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimespanMetricType.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Start tracking time for the provided metric.</p>
<p>This records an error if it’s already tracking time (i.e. <code>start</code> was
already called with no corresponding <code>stop</code>): in that case the original
start time will be preserved.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self) -&gt; None:
    &#34;&#34;&#34;
    Start tracking time for the provided metric.

    This records an error if it’s already tracking time (i.e. `start` was
    already called with no corresponding `stop`): in that case the original
    start time will be preserved.
    &#34;&#34;&#34;
    if self._disabled:
        return

    start_time = _util.time_ns()

    @Dispatcher.launch
    def start():
        _ffi.lib.glean_timespan_set_start(self._handle, start_time)</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimespanMetricType.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Stop tracking time for the provided metric.</p>
<p>Sets the metric to the elapsed time, but does not overwrite an already
existing value.
This will record an error if no <code>start</code> was called or there is an already
existing value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self) -&gt; None:
    &#34;&#34;&#34;
    Stop tracking time for the provided metric.

    Sets the metric to the elapsed time, but does not overwrite an already
    existing value.
    This will record an error if no `start` was called or there is an already
    existing value.
    &#34;&#34;&#34;
    if self._disabled:
        return

    stop_time = _util.time_ns()

    @Dispatcher.launch
    def stop():
        _ffi.lib.glean_timespan_set_stop(self._handle, stop_time)</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimespanMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: <a title="glean.testing.error_type.ErrorType" href="../testing/error_type.html#glean.testing.error_type.ErrorType">ErrorType</a>, ping_name: Union[str, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of errors recorded for the given metric.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>error_type</code></strong> :&ensp;<code>ErrorType</code></dt>
<dd>The type of error recorded.</dd>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>num_errors (int): The number of errors recorded for the metric for
the given error type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(
    self, error_type: ErrorType, ping_name: Optional[str] = None
) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of errors recorded for the given metric.

    Args:
        error_type (ErrorType): The type of error recorded.
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        num_errors (int): The number of errors recorded for the metric for
            the given error type.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return _ffi.lib.glean_timespan_test_get_num_recorded_errors(
        self._handle,
        error_type.value,
        _ffi.ffi_encode_string(ping_name),
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimespanMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the stored value for testing purposes only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (bool): value of the stored metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; int:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (bool): value of the stored metric.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    if not self.test_has_value(ping_name):
        raise ValueError(&#34;metric has no value&#34;)

    return _ffi.lib.glean_timespan_test_get_value(
        self._handle, _ffi.ffi_encode_string(ping_name)
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimespanMetricType.test_has_value"><code class="name flex">
<span>def <span class="ident">test_has_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether a value is stored for the metric for testing purposes
only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>has_value (bool): True if the metric value exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
    &#34;&#34;&#34;
    Tests whether a value is stored for the metric for testing purposes
    only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        has_value (bool): True if the metric value exists.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return bool(
        _ffi.lib.glean_timespan_test_has_value(
            self._handle, _ffi.ffi_encode_string(ping_name)
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.TimingDistributionMetricType"><code class="flex name class">
<span>class <span class="ident">TimingDistributionMetricType</span></span>
<span>(</span><span>disabled: bool, category: str, lifetime: <a title="glean.metrics.lifetime.Lifetime" href="lifetime.html#glean.metrics.lifetime.Lifetime">Lifetime</a>, name: str, send_in_pings: List[str], time_unit: <a title="glean.metrics.timeunit.TimeUnit" href="timeunit.html#glean.metrics.timeunit.TimeUnit">TimeUnit</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer facing API for recording timing distribution
metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimingDistributionMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording timing distribution
    metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.
    &#34;&#34;&#34;

    def __init__(
        self,
        disabled: bool,
        category: str,
        lifetime: Lifetime,
        name: str,
        send_in_pings: List[str],
        time_unit: TimeUnit,
    ):
        self._disabled = disabled
        self._send_in_pings = send_in_pings

        self._handle = _ffi.lib.glean_new_timing_distribution_metric(
            _ffi.ffi_encode_string(category),
            _ffi.ffi_encode_string(name),
            _ffi.ffi_encode_vec_string(send_in_pings),
            len(send_in_pings),
            lifetime.value,
            disabled,
            time_unit.value,
        )

    def __del__(self):
        if getattr(self, &#34;_handle&#34;, 0) != 0:
            _ffi.lib.glean_destroy_timing_distribution_metric(self._handle)

    def start(self) -&gt; Optional[int]:
        &#34;&#34;&#34;
        Start tracking time for the provided metric.
        Multiple timers can run simultaneously.

        Returns:
            timer_id: The object to associate with this timing.
        &#34;&#34;&#34;
        if self._disabled:
            return None

        # Even though the Rust code for `start` runs synchronously, the Rust
        # code for `stopAndAccumulate` runs asynchronously, and we need to use
        # the same clock for start and stop. Therefore we take the time on the
        # Python side, both here and in `stopAndAccumulate`.
        start_time = _util.time_ns()

        # No dispatcher, we need the return value
        return _ffi.lib.glean_timing_distribution_set_start(self._handle, start_time)

    def stop_and_accumulate(self, timer_id: Optional[int]) -&gt; None:
        &#34;&#34;&#34;
        Stop tracking time for the provided metric and associated timer id. Add a
        count to the corresponding bucket in the timing distribution.
        This will record an error if no `start` was called.

        Args:
            timer_id: The timer id associated with this timing. This allows for
                concurrent timing of events associated with different ids to
                the same timespan metric.
        &#34;&#34;&#34;
        # `start` may have returned None.
        # Accepting that means users of this API don&#39;t need to do a None check.
        if self._disabled or timer_id is None:
            return

        # The Rust code runs async and might be delayed. We need the time as
        # precisely as possible. We also need the same clock for start and stop
        # (`start` takes the time on the Python side).
        stop_time = _util.time_ns()

        @Dispatcher.launch
        def stop_and_accumulate():
            # CFFI prevents us from passing a negative value to
            # `glean_timing_distribution_set_stop_and_accumulate`. However, to be
            # consistent with the other platforms, we should still pass an invalid
            # value to the Rust side so it can record an error using the Glean
            # error reporting system.
            if timer_id &lt; 0:
                # 64-bit maxint
                corrected_timer_id = 0xFFFFFFFFFFFFFFFF
            else:
                corrected_timer_id = timer_id

            _ffi.lib.glean_timing_distribution_set_stop_and_accumulate(
                self._handle, corrected_timer_id, stop_time
            )

    def cancel(self, timer_id: Optional[int]) -&gt; None:
        &#34;&#34;&#34;
        Abort a previous `start` call. No error is recorded if no `start` was called.

        Args:
            timer_id: The timer id associated with this timing. This allows for
                concurrent timing of events associated with different ids to
                the same timing distribution metric.
        &#34;&#34;&#34;
        # `start` may have returned None.
        # Accepting that means users of this API don&#39;t need to do a None check.
        if self._disabled or timer_id is None:
            return

        @Dispatcher.launch
        def cancel():
            # CFFI prevents us from passing a negative value to
            # `glean_timing_distribution_cancel`. However, to be consistent
            # with the other platforms, we should still pass an invalid value
            # to the Rust side so it can record an error using the Glean error
            # reporting system.
            if timer_id &lt; 0:
                # 64-bit maxint
                corrected_timer_id = 0xFFFFFFFFFFFFFFFF
            else:
                corrected_timer_id = timer_id

            _ffi.lib.glean_timing_distribution_cancel(self._handle, corrected_timer_id)

    class _TimingDistributionContextManager:
        &#34;&#34;&#34;
        A context manager for recording timings. Used by the `measure` method.
        &#34;&#34;&#34;

        def __init__(self, timing_distribution: &#34;TimingDistributionMetricType&#34;):
            self._timing_distribution = timing_distribution

        def __enter__(self) -&gt; None:
            self._timer_id = self._timing_distribution.start()

        def __exit__(self, type, value, tb) -&gt; None:
            if tb is None:
                self._timing_distribution.stop_and_accumulate(self._timer_id)
            else:
                self._timing_distribution.cancel(self._timer_id)

    def measure(self) -&gt; &#34;_TimingDistributionContextManager&#34;:
        &#34;&#34;&#34;
        Provides a context manager for measuring the time it takes to execute
        snippets of code in a `with` statement.

        If the contents of the `with` statement raise an exception, the timing
        is not recorded.

        Usage:
            with metrics.perf.timer.measure():
                # ... do something that takes time ...
        &#34;&#34;&#34;
        return self._TimingDistributionContextManager(self)

    def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
        &#34;&#34;&#34;
        Tests whether a value is stored for the metric for testing purposes
        only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            has_value (bool): True if the metric value exists.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return bool(
            _ffi.lib.glean_timing_distribution_test_has_value(
                self._handle, _ffi.ffi_encode_string(ping_name)
            )
        )

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; DistributionData:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (DistriubutionData): value of the stored metric.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        if not self.test_has_value(ping_name):
            raise ValueError(&#34;metric has no value&#34;)

        return DistributionData.from_json_string(
            _ffi.ffi_decode_string(
                _ffi.lib.glean_timing_distribution_test_get_value_as_json_string(
                    self._handle, _ffi.ffi_encode_string(ping_name)
                )
            )
        )

    def test_get_num_recorded_errors(
        self, error_type: ErrorType, ping_name: Optional[str] = None
    ) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of errors recorded for the given metric.

        Args:
            error_type (ErrorType): The type of error recorded.
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            num_errors (int): The number of errors recorded for the metric for
                the given error type.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return _ffi.lib.glean_timing_distribution_test_get_num_recorded_errors(
            self._handle,
            error_type.value,
            _ffi.ffi_encode_string(ping_name),
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.TimingDistributionMetricType.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self, timer_id: Union[int, NoneType]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Abort a previous <code>start</code> call. No error is recorded if no <code>start</code> was called.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timer_id</code></strong></dt>
<dd>The timer id associated with this timing. This allows for
concurrent timing of events associated with different ids to
the same timing distribution metric.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel(self, timer_id: Optional[int]) -&gt; None:
    &#34;&#34;&#34;
    Abort a previous `start` call. No error is recorded if no `start` was called.

    Args:
        timer_id: The timer id associated with this timing. This allows for
            concurrent timing of events associated with different ids to
            the same timing distribution metric.
    &#34;&#34;&#34;
    # `start` may have returned None.
    # Accepting that means users of this API don&#39;t need to do a None check.
    if self._disabled or timer_id is None:
        return

    @Dispatcher.launch
    def cancel():
        # CFFI prevents us from passing a negative value to
        # `glean_timing_distribution_cancel`. However, to be consistent
        # with the other platforms, we should still pass an invalid value
        # to the Rust side so it can record an error using the Glean error
        # reporting system.
        if timer_id &lt; 0:
            # 64-bit maxint
            corrected_timer_id = 0xFFFFFFFFFFFFFFFF
        else:
            corrected_timer_id = timer_id

        _ffi.lib.glean_timing_distribution_cancel(self._handle, corrected_timer_id)</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimingDistributionMetricType.measure"><code class="name flex">
<span>def <span class="ident">measure</span></span>(<span>self) ‑> _TimingDistributionContextManager</span>
</code></dt>
<dd>
<div class="desc"><p>Provides a context manager for measuring the time it takes to execute
snippets of code in a <code>with</code> statement.</p>
<p>If the contents of the <code>with</code> statement raise an exception, the timing
is not recorded.</p>
<h2 id="usage">Usage</h2>
<p>with metrics.perf.timer.measure():
# &hellip; do something that takes time &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def measure(self) -&gt; &#34;_TimingDistributionContextManager&#34;:
    &#34;&#34;&#34;
    Provides a context manager for measuring the time it takes to execute
    snippets of code in a `with` statement.

    If the contents of the `with` statement raise an exception, the timing
    is not recorded.

    Usage:
        with metrics.perf.timer.measure():
            # ... do something that takes time ...
    &#34;&#34;&#34;
    return self._TimingDistributionContextManager(self)</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimingDistributionMetricType.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self) ‑> Union[int, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Start tracking time for the provided metric.
Multiple timers can run simultaneously.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>timer_id</code></dt>
<dd>The object to associate with this timing.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self) -&gt; Optional[int]:
    &#34;&#34;&#34;
    Start tracking time for the provided metric.
    Multiple timers can run simultaneously.

    Returns:
        timer_id: The object to associate with this timing.
    &#34;&#34;&#34;
    if self._disabled:
        return None

    # Even though the Rust code for `start` runs synchronously, the Rust
    # code for `stopAndAccumulate` runs asynchronously, and we need to use
    # the same clock for start and stop. Therefore we take the time on the
    # Python side, both here and in `stopAndAccumulate`.
    start_time = _util.time_ns()

    # No dispatcher, we need the return value
    return _ffi.lib.glean_timing_distribution_set_start(self._handle, start_time)</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimingDistributionMetricType.stop_and_accumulate"><code class="name flex">
<span>def <span class="ident">stop_and_accumulate</span></span>(<span>self, timer_id: Union[int, NoneType]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Stop tracking time for the provided metric and associated timer id. Add a
count to the corresponding bucket in the timing distribution.
This will record an error if no <code>start</code> was called.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timer_id</code></strong></dt>
<dd>The timer id associated with this timing. This allows for
concurrent timing of events associated with different ids to
the same timespan metric.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_and_accumulate(self, timer_id: Optional[int]) -&gt; None:
    &#34;&#34;&#34;
    Stop tracking time for the provided metric and associated timer id. Add a
    count to the corresponding bucket in the timing distribution.
    This will record an error if no `start` was called.

    Args:
        timer_id: The timer id associated with this timing. This allows for
            concurrent timing of events associated with different ids to
            the same timespan metric.
    &#34;&#34;&#34;
    # `start` may have returned None.
    # Accepting that means users of this API don&#39;t need to do a None check.
    if self._disabled or timer_id is None:
        return

    # The Rust code runs async and might be delayed. We need the time as
    # precisely as possible. We also need the same clock for start and stop
    # (`start` takes the time on the Python side).
    stop_time = _util.time_ns()

    @Dispatcher.launch
    def stop_and_accumulate():
        # CFFI prevents us from passing a negative value to
        # `glean_timing_distribution_set_stop_and_accumulate`. However, to be
        # consistent with the other platforms, we should still pass an invalid
        # value to the Rust side so it can record an error using the Glean
        # error reporting system.
        if timer_id &lt; 0:
            # 64-bit maxint
            corrected_timer_id = 0xFFFFFFFFFFFFFFFF
        else:
            corrected_timer_id = timer_id

        _ffi.lib.glean_timing_distribution_set_stop_and_accumulate(
            self._handle, corrected_timer_id, stop_time
        )</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimingDistributionMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: <a title="glean.testing.error_type.ErrorType" href="../testing/error_type.html#glean.testing.error_type.ErrorType">ErrorType</a>, ping_name: Union[str, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of errors recorded for the given metric.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>error_type</code></strong> :&ensp;<code>ErrorType</code></dt>
<dd>The type of error recorded.</dd>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>num_errors (int): The number of errors recorded for the metric for
the given error type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(
    self, error_type: ErrorType, ping_name: Optional[str] = None
) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of errors recorded for the given metric.

    Args:
        error_type (ErrorType): The type of error recorded.
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        num_errors (int): The number of errors recorded for the metric for
            the given error type.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return _ffi.lib.glean_timing_distribution_test_get_num_recorded_errors(
        self._handle,
        error_type.value,
        _ffi.ffi_encode_string(ping_name),
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimingDistributionMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> <a title="glean.metrics.distribution_data.DistributionData" href="distribution_data.html#glean.metrics.distribution_data.DistributionData">DistributionData</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the stored value for testing purposes only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (DistriubutionData): value of the stored metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; DistributionData:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (DistriubutionData): value of the stored metric.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    if not self.test_has_value(ping_name):
        raise ValueError(&#34;metric has no value&#34;)

    return DistributionData.from_json_string(
        _ffi.ffi_decode_string(
            _ffi.lib.glean_timing_distribution_test_get_value_as_json_string(
                self._handle, _ffi.ffi_encode_string(ping_name)
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.TimingDistributionMetricType.test_has_value"><code class="name flex">
<span>def <span class="ident">test_has_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether a value is stored for the metric for testing purposes
only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>has_value (bool): True if the metric value exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
    &#34;&#34;&#34;
    Tests whether a value is stored for the metric for testing purposes
    only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        has_value (bool): True if the metric value exists.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return bool(
        _ffi.lib.glean_timing_distribution_test_has_value(
            self._handle, _ffi.ffi_encode_string(ping_name)
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="glean.metrics.UuidMetricType"><code class="flex name class">
<span>class <span class="ident">UuidMetricType</span></span>
<span>(</span><span>disabled: bool, category: str, lifetime: <a title="glean.metrics.lifetime.Lifetime" href="lifetime.html#glean.metrics.lifetime.Lifetime">Lifetime</a>, name: str, send_in_pings: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>This implements the developer facing API for recording UUID metrics.</p>
<p>Instances of this class type are automatically generated by
<code><a title="glean.load_metrics" href="../index.html#glean.load_metrics">load_metrics()</a></code>, allowing developers to record values that were
previously registered in the metrics.yaml file.</p>
<p>The UUID API exposes the <code><a title="glean.metrics.UuidMetricType.generate_and_set" href="#glean.metrics.UuidMetricType.generate_and_set">UuidMetricType.generate_and_set()</a></code> and
<code><a title="glean.metrics.UuidMetricType.set" href="#glean.metrics.UuidMetricType.set">UuidMetricType.set()</a></code> methods.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UuidMetricType:
    &#34;&#34;&#34;
    This implements the developer facing API for recording UUID metrics.

    Instances of this class type are automatically generated by
    `glean.load_metrics`, allowing developers to record values that were
    previously registered in the metrics.yaml file.

    The UUID API exposes the `UuidMetricType.generate_and_set` and
    `UuidMetricType.set` methods.
    &#34;&#34;&#34;

    def __init__(
        self,
        disabled: bool,
        category: str,
        lifetime: Lifetime,
        name: str,
        send_in_pings: List[str],
    ):
        self._disabled = disabled
        self._send_in_pings = send_in_pings

        self._handle = _ffi.lib.glean_new_uuid_metric(
            _ffi.ffi_encode_string(category),
            _ffi.ffi_encode_string(name),
            _ffi.ffi_encode_vec_string(send_in_pings),
            len(send_in_pings),
            lifetime.value,
            disabled,
        )

    def __del__(self):
        if getattr(self, &#34;_handle&#34;, 0) != 0:
            _ffi.lib.glean_destroy_uuid_metric(self._handle)

    def generate_and_set(self) -&gt; Optional[uuid.UUID]:
        &#34;&#34;&#34;
        Generate a new UUID value and set it in the metric store.
        &#34;&#34;&#34;
        if self._disabled:
            return None

        id = uuid.uuid4()
        self.set(id)
        return id

    def set(self, value: uuid.UUID) -&gt; None:
        &#34;&#34;&#34;
        Explicitly set an existing UUID value.

        Args:
            value (uuid.UUID): A valid UUID to set the metric to.
        &#34;&#34;&#34;
        if self._disabled:
            return

        @Dispatcher.launch
        def set():
            _ffi.lib.glean_uuid_set(self._handle, _ffi.ffi_encode_string(str(value)))

    def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
        &#34;&#34;&#34;
        Tests whether a value is stored for the metric for testing purposes
        only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            has_value (bool): True if the metric value exists.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return bool(
            _ffi.lib.glean_uuid_test_has_value(
                self._handle, _ffi.ffi_encode_string(ping_name)
            )
        )

    def test_get_value(self, ping_name: Optional[str] = None) -&gt; uuid.UUID:
        &#34;&#34;&#34;
        Returns the stored value for testing purposes only.

        Args:
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            value (int): value of the stored metric.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        if not self.test_has_value(ping_name):
            raise ValueError(&#34;metric has no value&#34;)

        return uuid.UUID(
            &#34;urn:uuid:&#34;
            + _ffi.ffi_decode_string(
                _ffi.lib.glean_uuid_test_get_value(
                    self._handle, _ffi.ffi_encode_string(ping_name)
                )
            )
        )

    def test_get_num_recorded_errors(
        self, error_type: ErrorType, ping_name: Optional[str] = None
    ) -&gt; int:
        &#34;&#34;&#34;
        Returns the number of errors recorded for the given metric.

        Args:
            error_type (ErrorType): The type of error recorded.
            ping_name (str): (default: first value in send_in_pings) The name
                of the ping to retrieve the metric for.

        Returns:
            num_errors (int): The number of errors recorded for the metric for
                the given error type.
        &#34;&#34;&#34;
        if ping_name is None:
            ping_name = self._send_in_pings[0]

        return _ffi.lib.glean_uuid_test_get_num_recorded_errors(
            self._handle,
            error_type.value,
            _ffi.ffi_encode_string(ping_name),
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="glean.metrics.UuidMetricType.generate_and_set"><code class="name flex">
<span>def <span class="ident">generate_and_set</span></span>(<span>self) ‑> Union[uuid.UUID, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a new UUID value and set it in the metric store.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_and_set(self) -&gt; Optional[uuid.UUID]:
    &#34;&#34;&#34;
    Generate a new UUID value and set it in the metric store.
    &#34;&#34;&#34;
    if self._disabled:
        return None

    id = uuid.uuid4()
    self.set(id)
    return id</code></pre>
</details>
</dd>
<dt id="glean.metrics.UuidMetricType.set"><code class="name flex">
<span>def <span class="ident">set</span></span>(<span>self, value: uuid.UUID) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Explicitly set an existing UUID value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>uuid.UUID</code></dt>
<dd>A valid UUID to set the metric to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set(self, value: uuid.UUID) -&gt; None:
    &#34;&#34;&#34;
    Explicitly set an existing UUID value.

    Args:
        value (uuid.UUID): A valid UUID to set the metric to.
    &#34;&#34;&#34;
    if self._disabled:
        return

    @Dispatcher.launch
    def set():
        _ffi.lib.glean_uuid_set(self._handle, _ffi.ffi_encode_string(str(value)))</code></pre>
</details>
</dd>
<dt id="glean.metrics.UuidMetricType.test_get_num_recorded_errors"><code class="name flex">
<span>def <span class="ident">test_get_num_recorded_errors</span></span>(<span>self, error_type: <a title="glean.testing.error_type.ErrorType" href="../testing/error_type.html#glean.testing.error_type.ErrorType">ErrorType</a>, ping_name: Union[str, NoneType] = None) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the number of errors recorded for the given metric.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>error_type</code></strong> :&ensp;<code>ErrorType</code></dt>
<dd>The type of error recorded.</dd>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>num_errors (int): The number of errors recorded for the metric for
the given error type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_num_recorded_errors(
    self, error_type: ErrorType, ping_name: Optional[str] = None
) -&gt; int:
    &#34;&#34;&#34;
    Returns the number of errors recorded for the given metric.

    Args:
        error_type (ErrorType): The type of error recorded.
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        num_errors (int): The number of errors recorded for the metric for
            the given error type.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return _ffi.lib.glean_uuid_test_get_num_recorded_errors(
        self._handle,
        error_type.value,
        _ffi.ffi_encode_string(ping_name),
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.UuidMetricType.test_get_value"><code class="name flex">
<span>def <span class="ident">test_get_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> uuid.UUID</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the stored value for testing purposes only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>value (int): value of the stored metric.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_get_value(self, ping_name: Optional[str] = None) -&gt; uuid.UUID:
    &#34;&#34;&#34;
    Returns the stored value for testing purposes only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        value (int): value of the stored metric.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    if not self.test_has_value(ping_name):
        raise ValueError(&#34;metric has no value&#34;)

    return uuid.UUID(
        &#34;urn:uuid:&#34;
        + _ffi.ffi_decode_string(
            _ffi.lib.glean_uuid_test_get_value(
                self._handle, _ffi.ffi_encode_string(ping_name)
            )
        )
    )</code></pre>
</details>
</dd>
<dt id="glean.metrics.UuidMetricType.test_has_value"><code class="name flex">
<span>def <span class="ident">test_has_value</span></span>(<span>self, ping_name: Union[str, NoneType] = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Tests whether a value is stored for the metric for testing purposes
only.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ping_name</code></strong> :&ensp;<code>str</code></dt>
<dd>(default: first value in send_in_pings) The name
of the ping to retrieve the metric for.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>has_value (bool): True if the metric value exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_has_value(self, ping_name: Optional[str] = None) -&gt; bool:
    &#34;&#34;&#34;
    Tests whether a value is stored for the metric for testing purposes
    only.

    Args:
        ping_name (str): (default: first value in send_in_pings) The name
            of the ping to retrieve the metric for.

    Returns:
        has_value (bool): True if the metric value exists.
    &#34;&#34;&#34;
    if ping_name is None:
        ping_name = self._send_in_pings[0]

    return bool(
        _ffi.lib.glean_uuid_test_has_value(
            self._handle, _ffi.ffi_encode_string(ping_name)
        )
    )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="glean" href="../index.html">glean</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="glean.metrics.boolean" href="boolean.html">glean.metrics.boolean</a></code></li>
<li><code><a title="glean.metrics.counter" href="counter.html">glean.metrics.counter</a></code></li>
<li><code><a title="glean.metrics.datetime" href="datetime.html">glean.metrics.datetime</a></code></li>
<li><code><a title="glean.metrics.distribution_data" href="distribution_data.html">glean.metrics.distribution_data</a></code></li>
<li><code><a title="glean.metrics.event" href="event.html">glean.metrics.event</a></code></li>
<li><code><a title="glean.metrics.experiment" href="experiment.html">glean.metrics.experiment</a></code></li>
<li><code><a title="glean.metrics.jwe" href="jwe.html">glean.metrics.jwe</a></code></li>
<li><code><a title="glean.metrics.labeled" href="labeled.html">glean.metrics.labeled</a></code></li>
<li><code><a title="glean.metrics.lifetime" href="lifetime.html">glean.metrics.lifetime</a></code></li>
<li><code><a title="glean.metrics.memory_distribution" href="memory_distribution.html">glean.metrics.memory_distribution</a></code></li>
<li><code><a title="glean.metrics.memoryunit" href="memoryunit.html">glean.metrics.memoryunit</a></code></li>
<li><code><a title="glean.metrics.ping" href="ping.html">glean.metrics.ping</a></code></li>
<li><code><a title="glean.metrics.quantity" href="quantity.html">glean.metrics.quantity</a></code></li>
<li><code><a title="glean.metrics.string" href="string.html">glean.metrics.string</a></code></li>
<li><code><a title="glean.metrics.string_list" href="string_list.html">glean.metrics.string_list</a></code></li>
<li><code><a title="glean.metrics.timespan" href="timespan.html">glean.metrics.timespan</a></code></li>
<li><code><a title="glean.metrics.timeunit" href="timeunit.html">glean.metrics.timeunit</a></code></li>
<li><code><a title="glean.metrics.timing_distribution" href="timing_distribution.html">glean.metrics.timing_distribution</a></code></li>
<li><code><a title="glean.metrics.uuid" href="uuid.html">glean.metrics.uuid</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="glean.metrics.BooleanMetricType" href="#glean.metrics.BooleanMetricType">BooleanMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.BooleanMetricType.set" href="#glean.metrics.BooleanMetricType.set">set</a></code></li>
<li><code><a title="glean.metrics.BooleanMetricType.test_get_value" href="#glean.metrics.BooleanMetricType.test_get_value">test_get_value</a></code></li>
<li><code><a title="glean.metrics.BooleanMetricType.test_has_value" href="#glean.metrics.BooleanMetricType.test_has_value">test_has_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.CounterMetricType" href="#glean.metrics.CounterMetricType">CounterMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.CounterMetricType.add" href="#glean.metrics.CounterMetricType.add">add</a></code></li>
<li><code><a title="glean.metrics.CounterMetricType.test_get_num_recorded_errors" href="#glean.metrics.CounterMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.CounterMetricType.test_get_value" href="#glean.metrics.CounterMetricType.test_get_value">test_get_value</a></code></li>
<li><code><a title="glean.metrics.CounterMetricType.test_has_value" href="#glean.metrics.CounterMetricType.test_has_value">test_has_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.DatetimeMetricType" href="#glean.metrics.DatetimeMetricType">DatetimeMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.DatetimeMetricType.set" href="#glean.metrics.DatetimeMetricType.set">set</a></code></li>
<li><code><a title="glean.metrics.DatetimeMetricType.test_get_num_recorded_errors" href="#glean.metrics.DatetimeMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.DatetimeMetricType.test_get_value" href="#glean.metrics.DatetimeMetricType.test_get_value">test_get_value</a></code></li>
<li><code><a title="glean.metrics.DatetimeMetricType.test_get_value_as_str" href="#glean.metrics.DatetimeMetricType.test_get_value_as_str">test_get_value_as_str</a></code></li>
<li><code><a title="glean.metrics.DatetimeMetricType.test_has_value" href="#glean.metrics.DatetimeMetricType.test_has_value">test_has_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.EventMetricType" href="#glean.metrics.EventMetricType">EventMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.EventMetricType.record" href="#glean.metrics.EventMetricType.record">record</a></code></li>
<li><code><a title="glean.metrics.EventMetricType.test_get_num_recorded_errors" href="#glean.metrics.EventMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.EventMetricType.test_get_value" href="#glean.metrics.EventMetricType.test_get_value">test_get_value</a></code></li>
<li><code><a title="glean.metrics.EventMetricType.test_has_value" href="#glean.metrics.EventMetricType.test_has_value">test_has_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.JweMetricType" href="#glean.metrics.JweMetricType">JweMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.JweMetricType.set" href="#glean.metrics.JweMetricType.set">set</a></code></li>
<li><code><a title="glean.metrics.JweMetricType.set_with_compact_representation" href="#glean.metrics.JweMetricType.set_with_compact_representation">set_with_compact_representation</a></code></li>
<li><code><a title="glean.metrics.JweMetricType.test_get_compact_representation" href="#glean.metrics.JweMetricType.test_get_compact_representation">test_get_compact_representation</a></code></li>
<li><code><a title="glean.metrics.JweMetricType.test_get_num_recorded_errors" href="#glean.metrics.JweMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.JweMetricType.test_get_value" href="#glean.metrics.JweMetricType.test_get_value">test_get_value</a></code></li>
<li><code><a title="glean.metrics.JweMetricType.test_has_value" href="#glean.metrics.JweMetricType.test_has_value">test_has_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.LabeledBooleanMetricType" href="#glean.metrics.LabeledBooleanMetricType">LabeledBooleanMetricType</a></code></h4>
</li>
<li>
<h4><code><a title="glean.metrics.LabeledCounterMetricType" href="#glean.metrics.LabeledCounterMetricType">LabeledCounterMetricType</a></code></h4>
</li>
<li>
<h4><code><a title="glean.metrics.LabeledStringMetricType" href="#glean.metrics.LabeledStringMetricType">LabeledStringMetricType</a></code></h4>
</li>
<li>
<h4><code><a title="glean.metrics.Lifetime" href="#glean.metrics.Lifetime">Lifetime</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.Lifetime.APPLICATION" href="#glean.metrics.Lifetime.APPLICATION">APPLICATION</a></code></li>
<li><code><a title="glean.metrics.Lifetime.PING" href="#glean.metrics.Lifetime.PING">PING</a></code></li>
<li><code><a title="glean.metrics.Lifetime.USER" href="#glean.metrics.Lifetime.USER">USER</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.MemoryDistributionMetricType" href="#glean.metrics.MemoryDistributionMetricType">MemoryDistributionMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.MemoryDistributionMetricType.accumulate" href="#glean.metrics.MemoryDistributionMetricType.accumulate">accumulate</a></code></li>
<li><code><a title="glean.metrics.MemoryDistributionMetricType.test_get_num_recorded_errors" href="#glean.metrics.MemoryDistributionMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.MemoryDistributionMetricType.test_get_value" href="#glean.metrics.MemoryDistributionMetricType.test_get_value">test_get_value</a></code></li>
<li><code><a title="glean.metrics.MemoryDistributionMetricType.test_has_value" href="#glean.metrics.MemoryDistributionMetricType.test_has_value">test_has_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.MemoryUnit" href="#glean.metrics.MemoryUnit">MemoryUnit</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.MemoryUnit.BYTE" href="#glean.metrics.MemoryUnit.BYTE">BYTE</a></code></li>
<li><code><a title="glean.metrics.MemoryUnit.GIGABYTE" href="#glean.metrics.MemoryUnit.GIGABYTE">GIGABYTE</a></code></li>
<li><code><a title="glean.metrics.MemoryUnit.KILOBYTE" href="#glean.metrics.MemoryUnit.KILOBYTE">KILOBYTE</a></code></li>
<li><code><a title="glean.metrics.MemoryUnit.MEGABYTE" href="#glean.metrics.MemoryUnit.MEGABYTE">MEGABYTE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.PingType" href="#glean.metrics.PingType">PingType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.PingType.name" href="#glean.metrics.PingType.name">name</a></code></li>
<li><code><a title="glean.metrics.PingType.submit" href="#glean.metrics.PingType.submit">submit</a></code></li>
<li><code><a title="glean.metrics.PingType.test_before_next_submit" href="#glean.metrics.PingType.test_before_next_submit">test_before_next_submit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.QuantityMetricType" href="#glean.metrics.QuantityMetricType">QuantityMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.QuantityMetricType.set" href="#glean.metrics.QuantityMetricType.set">set</a></code></li>
<li><code><a title="glean.metrics.QuantityMetricType.test_get_num_recorded_errors" href="#glean.metrics.QuantityMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.QuantityMetricType.test_get_value" href="#glean.metrics.QuantityMetricType.test_get_value">test_get_value</a></code></li>
<li><code><a title="glean.metrics.QuantityMetricType.test_has_value" href="#glean.metrics.QuantityMetricType.test_has_value">test_has_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.RecordedEventData" href="#glean.metrics.RecordedEventData">RecordedEventData</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.RecordedEventData.category" href="#glean.metrics.RecordedEventData.category">category</a></code></li>
<li><code><a title="glean.metrics.RecordedEventData.extra" href="#glean.metrics.RecordedEventData.extra">extra</a></code></li>
<li><code><a title="glean.metrics.RecordedEventData.identifier" href="#glean.metrics.RecordedEventData.identifier">identifier</a></code></li>
<li><code><a title="glean.metrics.RecordedEventData.name" href="#glean.metrics.RecordedEventData.name">name</a></code></li>
<li><code><a title="glean.metrics.RecordedEventData.timestamp" href="#glean.metrics.RecordedEventData.timestamp">timestamp</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.RecordedExperimentData" href="#glean.metrics.RecordedExperimentData">RecordedExperimentData</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.RecordedExperimentData.branch" href="#glean.metrics.RecordedExperimentData.branch">branch</a></code></li>
<li><code><a title="glean.metrics.RecordedExperimentData.extra" href="#glean.metrics.RecordedExperimentData.extra">extra</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.StringListMetricType" href="#glean.metrics.StringListMetricType">StringListMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.StringListMetricType.add" href="#glean.metrics.StringListMetricType.add">add</a></code></li>
<li><code><a title="glean.metrics.StringListMetricType.set" href="#glean.metrics.StringListMetricType.set">set</a></code></li>
<li><code><a title="glean.metrics.StringListMetricType.test_get_num_recorded_errors" href="#glean.metrics.StringListMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.StringListMetricType.test_get_value" href="#glean.metrics.StringListMetricType.test_get_value">test_get_value</a></code></li>
<li><code><a title="glean.metrics.StringListMetricType.test_has_value" href="#glean.metrics.StringListMetricType.test_has_value">test_has_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.StringMetricType" href="#glean.metrics.StringMetricType">StringMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.StringMetricType.set" href="#glean.metrics.StringMetricType.set">set</a></code></li>
<li><code><a title="glean.metrics.StringMetricType.test_get_num_recorded_errors" href="#glean.metrics.StringMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.StringMetricType.test_get_value" href="#glean.metrics.StringMetricType.test_get_value">test_get_value</a></code></li>
<li><code><a title="glean.metrics.StringMetricType.test_has_value" href="#glean.metrics.StringMetricType.test_has_value">test_has_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.TimeUnit" href="#glean.metrics.TimeUnit">TimeUnit</a></code></h4>
<ul class="two-column">
<li><code><a title="glean.metrics.TimeUnit.DAY" href="#glean.metrics.TimeUnit.DAY">DAY</a></code></li>
<li><code><a title="glean.metrics.TimeUnit.HOUR" href="#glean.metrics.TimeUnit.HOUR">HOUR</a></code></li>
<li><code><a title="glean.metrics.TimeUnit.MICROSECOND" href="#glean.metrics.TimeUnit.MICROSECOND">MICROSECOND</a></code></li>
<li><code><a title="glean.metrics.TimeUnit.MILLISECOND" href="#glean.metrics.TimeUnit.MILLISECOND">MILLISECOND</a></code></li>
<li><code><a title="glean.metrics.TimeUnit.MINUTE" href="#glean.metrics.TimeUnit.MINUTE">MINUTE</a></code></li>
<li><code><a title="glean.metrics.TimeUnit.NANOSECOND" href="#glean.metrics.TimeUnit.NANOSECOND">NANOSECOND</a></code></li>
<li><code><a title="glean.metrics.TimeUnit.SECOND" href="#glean.metrics.TimeUnit.SECOND">SECOND</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.TimespanMetricType" href="#glean.metrics.TimespanMetricType">TimespanMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.TimespanMetricType.cancel" href="#glean.metrics.TimespanMetricType.cancel">cancel</a></code></li>
<li><code><a title="glean.metrics.TimespanMetricType.measure" href="#glean.metrics.TimespanMetricType.measure">measure</a></code></li>
<li><code><a title="glean.metrics.TimespanMetricType.set_raw_nanos" href="#glean.metrics.TimespanMetricType.set_raw_nanos">set_raw_nanos</a></code></li>
<li><code><a title="glean.metrics.TimespanMetricType.start" href="#glean.metrics.TimespanMetricType.start">start</a></code></li>
<li><code><a title="glean.metrics.TimespanMetricType.stop" href="#glean.metrics.TimespanMetricType.stop">stop</a></code></li>
<li><code><a title="glean.metrics.TimespanMetricType.test_get_num_recorded_errors" href="#glean.metrics.TimespanMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.TimespanMetricType.test_get_value" href="#glean.metrics.TimespanMetricType.test_get_value">test_get_value</a></code></li>
<li><code><a title="glean.metrics.TimespanMetricType.test_has_value" href="#glean.metrics.TimespanMetricType.test_has_value">test_has_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.TimingDistributionMetricType" href="#glean.metrics.TimingDistributionMetricType">TimingDistributionMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.TimingDistributionMetricType.cancel" href="#glean.metrics.TimingDistributionMetricType.cancel">cancel</a></code></li>
<li><code><a title="glean.metrics.TimingDistributionMetricType.measure" href="#glean.metrics.TimingDistributionMetricType.measure">measure</a></code></li>
<li><code><a title="glean.metrics.TimingDistributionMetricType.start" href="#glean.metrics.TimingDistributionMetricType.start">start</a></code></li>
<li><code><a title="glean.metrics.TimingDistributionMetricType.stop_and_accumulate" href="#glean.metrics.TimingDistributionMetricType.stop_and_accumulate">stop_and_accumulate</a></code></li>
<li><code><a title="glean.metrics.TimingDistributionMetricType.test_get_num_recorded_errors" href="#glean.metrics.TimingDistributionMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.TimingDistributionMetricType.test_get_value" href="#glean.metrics.TimingDistributionMetricType.test_get_value">test_get_value</a></code></li>
<li><code><a title="glean.metrics.TimingDistributionMetricType.test_has_value" href="#glean.metrics.TimingDistributionMetricType.test_has_value">test_has_value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="glean.metrics.UuidMetricType" href="#glean.metrics.UuidMetricType">UuidMetricType</a></code></h4>
<ul class="">
<li><code><a title="glean.metrics.UuidMetricType.generate_and_set" href="#glean.metrics.UuidMetricType.generate_and_set">generate_and_set</a></code></li>
<li><code><a title="glean.metrics.UuidMetricType.set" href="#glean.metrics.UuidMetricType.set">set</a></code></li>
<li><code><a title="glean.metrics.UuidMetricType.test_get_num_recorded_errors" href="#glean.metrics.UuidMetricType.test_get_num_recorded_errors">test_get_num_recorded_errors</a></code></li>
<li><code><a title="glean.metrics.UuidMetricType.test_get_value" href="#glean.metrics.UuidMetricType.test_get_value">test_get_value</a></code></li>
<li><code><a title="glean.metrics.UuidMetricType.test_has_value" href="#glean.metrics.UuidMetricType.test_has_value">test_has_value</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>